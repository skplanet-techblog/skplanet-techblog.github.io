{"componentChunkName":"component---src-templates-blog-post-js","path":"/syrupapp-refactoring/","result":{"data":{"site":{"siteMetadata":{"title":"SK플래닛 TECH TOPIC"}},"markdownRemark":{"id":"16e67e25-766e-516f-b9dd-83025319d7ab","excerpt":"Syrup은 재미있게 포인트 모으기, 모은 포인트 투자, 쿠폰 활용, 할인 혜택, 멤버십과 자산 내역 등을 한 곳에서 관리하는 SK플래닛의 대표 서비스입니다. SK플래닛은 고객에게 더 좋은 경험을 제공하기 위해서 응답 속도 위주로 Syrup 서비스를 개선했습니다. 본 내용은 Syrup…","html":"<p>Syrup은 재미있게 포인트 모으기, 모은 포인트 투자, 쿠폰 활용, 할인 혜택, 멤버십과 자산 내역 등을 한 곳에서 관리하는 SK플래닛의 대표 서비스입니다.<br>\nSK플래닛은 고객에게 더 좋은 경험을 제공하기 위해서 응답 속도 위주로 Syrup 서비스를 개선했습니다.<br>\n본 내용은 Syrup 서비스 개선에 적용한 기술, 해당 기술을 채택한 이유, 개선 과정에서 경험한 시행 착오 그리고 개선 결과입니다.</p>\n<h1>개선 배경</h1>\n<p>Syrup 서비스는 2010년에 처음 출시되어 13년 이상, SK플래닛 고객이 사용하고 있습니다(2023년 기준).<br>\n이렇게 오랜 기간 Syrup 서비스를 제공하면서 API 서버의 레거시화가 진행되었는데, 특히 모바일 웹이 호출하는 웹 게이트웨이 서버의 응답 속도가 문제였습니다.<br>\n이러한 웹 게이트웨이의 느린 응답은 전체 Syrup 모바일 웹의 로딩과 렌더링 속도에 직접적인 영향을 주었고, Syrup 모바일 웹의 응답 속도와 서비스 개선을 위하여 신규 서버 구축의 필요성이 대두되었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/63cf0f3963c5d4f942332c052fb590d7/7c1cd/syrup-01.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.39240506329114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACFElEQVR42n2TyW7UQBCG51UjceMNQOLGI0SIC+QJOEVwicIiLjlAmEyijJKB8TbjfWt3u73OT1XHQ0AiKalUclf791eLZ8vrJS4vFph/P8difoEf5+cQpQDbbrfD/ywvCvhBgM1mgyiKkKQpKilNbmYHW+S9RjG2JrppBFXXDwp2XQfLto1ISGJZlhmXe0Fx9AntkzfoD15hODiEfnqINspMciRBltw7m6wqBGGIMI7hEaHLlEkCQed3gu++Qj0/QvPiLZpnryFfUkzyu7d3471Pklzm2rIQk4hFkWmLsrwXVLKEaiX6ccA4auiuRU9lqabDOlNwRQuP3C40vCiF6zhI8xwBlcsxpXL/IYxDShB+3w0o1IhaNRB06cr2cfKrxPvLLY7nLk5thQ9nC3iOhS0NhCl934dNhCG1oJLK9HxW0sSGYUSjK/xc36IQGkqUWPkpPtsSp6sMJzcJvngaH+c38D0XpRCGkMuOJi/FRFhNqF3boEhDKKVQ05S7YYBfKESyQVw1CESNvFLYUg8d1/1Dx5EJuWRD6Dselmffpq9IGr+CbpoH16agitIsN7v4t0sCMYSB58G6ujZfKGmhq0qimQTHcTSie2fj3O1qZfroTmvjkPNzS8Oc8ZR025KQQJ7zkqbQWj/6p8RJagRqusdkvNQlAWVEOuOeKTrgyEKc7Psej1lP/eXF5grY+e8xS68UfgM8gI3W0EBVogAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-01\"\n        title=\"\"\n        src=\"/static/63cf0f3963c5d4f942332c052fb590d7/7c1cd/syrup-01.png\"\n        srcset=\"/static/63cf0f3963c5d4f942332c052fb590d7/c26ae/syrup-01.png 158w,\n/static/63cf0f3963c5d4f942332c052fb590d7/6bdcf/syrup-01.png 315w,\n/static/63cf0f3963c5d4f942332c052fb590d7/7c1cd/syrup-01.png 582w\"\n        sizes=\"(max-width: 582px) 100vw, 582px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h1>현상 및 개선 목표</h1>\n<p>Syrup은 멤버십 카드/쿠폰, 불리기(금, 조각, 주식, 가상화폐, 부동산), 마이데이터 등의 서비스를 제공하기 위하여 많은 외부 파트너와 제휴하고 있습니다.</p>\n<p>지금까지 Syrup 웹 게이트웨이는 파트너가 제공하는 정보를 조회하기 위하여 다수의 API를 호출하는데, 다음의 방법으로 API를 호출했습니다.</p>\n<p>첫 번째는 웹 게이트웨이가 순차적으로 API를 호출하여 모든 응답이 완료될 때까지 대기한 후, 최종으로 데이터를 병합하여 클라이언트(프론트엔드)로 보내는 방법입니다.<br>\n이처럼 다수의 API를 순차적으로 처리할 때, 응답 시간이 지연되는 문제가 있습니다.</p>\n<p>예를 들어, 다음 그림에서 Gateway의 getSummary API 응답 시간은 Gateway 내부에서 호출하는 API인 getToken, getMember, getFinanceInfo, getCardInfo, getCouponInfo, getProfitInfo 의 응답 시간을 합한 것입니다.<br>\n이러한 결과로 전체 API 응답 시간은 402.063 ms가 되어 클라이언트가 getSummary API를 호출한 후, 대기 시간이 길어지는 문제가 있었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/95510340db6f39e9eedfe4dc70a4a685/e80ec/syrup-02.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.316455696202528%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGUlEQVR42l2Q3U6DQBCFeUVfRp/Fa73XKxEDCqaJJIoiWGgJAi1YSvlpof6hsMcBxRg3OZmd7JzZb4YLoxW0Ox1JHEL1PeyrN1AefahhhKvwCaN5BMULcHJvkgzwxgNkyhV/9qvLYAaJPEGxBpdmGXhBgijK0B0X11Q8smyI1MBexMjyHO91jeEwxtC2LZqm6eN/cYu0xKFg4+DUQpxVvWlZbTHPC0yTBLxuQLImMP0AbhShrj/AyPi3eZe3dO8it8k86PIebi92sc5cNFTL2qY3dMWvRPdG0mg02Z5CnTg4p7Fdoq/KEp8/pAMxtypsHCs7OCIlxbhvNDx+k7AOpafpTrwp4SwTaLTbbq+COYZIE5zRZ+nzC74AgBpu7nvxLP4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-02\"\n        title=\"\"\n        src=\"/static/95510340db6f39e9eedfe4dc70a4a685/f058b/syrup-02.png\"\n        srcset=\"/static/95510340db6f39e9eedfe4dc70a4a685/c26ae/syrup-02.png 158w,\n/static/95510340db6f39e9eedfe4dc70a4a685/6bdcf/syrup-02.png 315w,\n/static/95510340db6f39e9eedfe4dc70a4a685/f058b/syrup-02.png 630w,\n/static/95510340db6f39e9eedfe4dc70a4a685/40601/syrup-02.png 945w,\n/static/95510340db6f39e9eedfe4dc70a4a685/78612/syrup-02.png 1260w,\n/static/95510340db6f39e9eedfe4dc70a4a685/e80ec/syrup-02.png 2582w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이때 응답 시간을 줄이기 위한 방법으로 서로 의존성이 없는 API를 비동기로 호출하기도 했습니다.<br>\n이 방법은 getSummary API의 응답 시간은 단축되지만, 가장 많은 시간이 소요되는 API에 의존하게 됩니다(다음 그림에서 ProfitService의 getProfitInfo API 응답 시간에 의존).<br>\n특히 특정 API가 타임아웃 시간까지 대기하면, 전체 응답 시간은 타임아웃 시간까지 지연됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/575745dfd2f54b7e9ddee43934eedce4/36405/syrup-03.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.58227848101266%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIklEQVR42m2Qy07CYBBG+26+gM/iA7jlDXTrRmEnxFSLBCGEAlaJoRS5ChR6CSgXIYaaXo4/jbowTnIyi5k5mXyS477RNHQca0DLMTlVNZRun7pl8+i4aLZLbWpT7PYodnoU2l3KozHViS2wflHNKU13hrRYrpCVAulMlkZngD6ZUh+OuKo90DAnLBcLvN0OoogwDOO+J/rDz1yaLzek8j3OrlsMrCX72uw87NWa/mxOsqqRFPLzyj1Kq034ffgfQRAgva8s9NIxWu6IV6eOL54IAj8Wbz2Pk5JKIiOTkBVumgYf2218HP0jjoWL9Qi5fMjl3QGmm49FQRgQiYVP3yctvrp40kk1DLIi21vdINd6FrQpvQxRRX4VkV9xOMZar/kCc6FqUNdwe2UAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-03\"\n        title=\"\"\n        src=\"/static/575745dfd2f54b7e9ddee43934eedce4/f058b/syrup-03.png\"\n        srcset=\"/static/575745dfd2f54b7e9ddee43934eedce4/c26ae/syrup-03.png 158w,\n/static/575745dfd2f54b7e9ddee43934eedce4/6bdcf/syrup-03.png 315w,\n/static/575745dfd2f54b7e9ddee43934eedce4/f058b/syrup-03.png 630w,\n/static/575745dfd2f54b7e9ddee43934eedce4/40601/syrup-03.png 945w,\n/static/575745dfd2f54b7e9ddee43934eedce4/78612/syrup-03.png 1260w,\n/static/575745dfd2f54b7e9ddee43934eedce4/36405/syrup-03.png 2486w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>또한 스프링 MVC(Model, View, Controller)를 사용할 경우, 비동기 호출을 위해 일반적으로  CompletableFuture를 사용하는데, CompletableFuture는 다음과 같은 문제가 있습니다.</p>\n<ul>\n<li><strong>복잡성</strong></li>\n</ul>\n<p>CompletableFuture를 사용하면 코드가 복잡해질 수 있습니다. 특히 여러 개의 thenCombine을 조합하여 연결할 때, 다음 코드와 같이 콜백 함수와 데이터 병합 코드로 인해 가독성이 떨어질 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static void main(String[] args) {\r\n    CompletableFuture&lt;String> SK = CompletableFuture.supplyAsync(() ->\r\n        \"SK\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Planet = CompletableFuture.supplyAsync(() ->\r\n        \"Planet\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Syrup = CompletableFuture.supplyAsync(() ->\r\n        \"Syrup\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Development = CompletableFuture.supplyAsync(() ->\r\n        \"Development\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Team = CompletableFuture.supplyAsync(() ->\r\n        \"Team\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> future = SK\r\n        .thenCombine(Planet, (result, planet) -> result + \" \" + planet)\r\n        .thenCombine(Syrup, (result, syrup) -> result + \" \" + syrup)\r\n        .thenCombine(Development, (result, development) -> result + \" \" + development)\r\n        .thenCombine(Team, (result, team) -> result + \" \" + team);\r\n\r\n    try {\r\n        System.out.println(future.get());\r\n    } catch (InterruptedException | ExecutionException e) {}\r\n}</code></pre></div>\n<ul>\n<li><strong>스레드 풀 관리</strong></li>\n</ul>\n<p>CompletableFuture는 백그라운드 스레드 풀을 사용하여 비동기 작업을 하기 때문에 스레드 풀을 관리해야 합니다. 스레드 풀을 관리하지 않으면 스레드가 과도하게 생성되거나 리소스 누수 문제가 발생될 수 있습니다.<br>\n실제 CompletableFuture 사용 시, 별도로 스레드 풀을 관리하지 않아서 장애가 발생된 경험이 있습니다.</p>\n<ul>\n<li><strong>콘텍스트 스위칭 비용</strong></li>\n</ul>\n<p>비동기 API 호출을 위해 작업이 다른 스레드로 전환될 때, 추가 시간과 메모리 사용 등 오버헤드 비용이 발생하여 전체적인 서버 성능에 영향을 미칠 수 있습니다.</p>\n<p>두 번째는 클라이언트에서 다수의 API를 병렬 호출하여 전체 응답을 화면에서 처리하는 방법입니다.<br>\n특히 React, Vue와 같은 모던 프론트엔드 개발 환경은 전체 페이지 단위가 아닌 컴포넌트 단위로 API를 호출하는 사례가 많아지면서 이와 같은 병렬 호출 방법이 주로 사용됩니다.</p>\n<p>다수의 API를 호출할 때에도 다음 그림과 같이 AuthService, MemberService에서 제공하는 API(인증/인가 등)가 중복 호출되는 문제가 발생되어 AuthService, MemberService의 트래픽을 증가시키고 있었습니다. 또한 Gateway API 호출 건수가 많아짐에 따라 고객의 네트워크 비용도 증가 됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d3813c9a5de3d8c9e119005b1ffcd9e8/e996b/syrup-04.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.79746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACj0lEQVR42jWSTXPSYBSF+Sv+ADf+LV266t5t97pyph3HhTo6XWhbR1sstJTSD1oIgZQQCB+BQEJCPghJHy8ZzcyZd5K899xzzz0FtauhdDs0NJV7wWO/x/aZzlzqDQ3TMKk0m3yp3XLaVDhrqRxf1Ti8b3D40OSk26PY63OiG9SGIwq+2mfTNEnVEVFNIzYmZE8Z47HF6UmZm4saJSn8oXYotTXOhcAaTwg8jzhJSNKUjSDZbHIUwpfv8V/sED1/TfTsFcnOfq6wZTyw+/kNb7/tspiN82+6NUURFXWtS0VUXRl9zqXJ5aPOjQjQFw6F9V2TZbFGclHH+1lirQ0gywjiFYOFhuXoBCuPIM0IRUkgKozhEG1i0RZoMzsn6jou1iqgsFw6LDwnV/BEJlwywnotHs5ptRQmfZ2jep13l9cURVlZ71GqP1DudChrj1T7JrdCXB2O0eYL8VDY12GILQT6cE4WJjxtEnrGkP0PBxx8PUbpaKiWxZ+Gwve7OqqQTuQ9SDaspLkfRfhxnHtaiIMgV+fODOaWSRxEpOuYheNzVrqjenFP6Hr5nW2RJxgIWVU8LKuyJGl23u5waQwwPZ+CJx7Y4omzcAn8FYkUpNJp6UWMLQ937qONRlyNxihytzG1qbbaVB67XMgyauaIW9n69n93u5RBq4NSvWHuunjeKl99lm1jM6JU/oVyV+Ho+po9yeHvhwbX/QG9noE5nTGWmpkswhbLpn6AG0YUIlG0Fh+CIMRxxM94nY/X0Se8+1hk79MZ9mRGnG44U9tcCVldRmyYQ5TRRE6TlpyqqJ/6MvJGjE22Af2HVKKxfQJp1LNtBoJYQpytVmTzOamcfcljVzaqyqj/o7ONjR2E/AXqUyOU6zYqFQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-04\"\n        title=\"\"\n        src=\"/static/d3813c9a5de3d8c9e119005b1ffcd9e8/f058b/syrup-04.png\"\n        srcset=\"/static/d3813c9a5de3d8c9e119005b1ffcd9e8/c26ae/syrup-04.png 158w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/6bdcf/syrup-04.png 315w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/f058b/syrup-04.png 630w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/40601/syrup-04.png 945w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/e996b/syrup-04.png 1050w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이러한 문제를 해결하기 위해 신규로 구축되는 Syrup 웹 게이트웨이에는 WebFlux, Server Sent Events를 적용하여 신규 서버를 구축했고, 추가로 모던 프론트엔드 개발 환경을 통한 렌더링 성능 향상 및 사용자 경험 개선을 위해 프론트엔드 환경도 Next.js를 적용했습니다.</p>\n<h1>적용 기술</h1>\n<h2>1. WebFlux</h2>\n<p>WebFlux(<a href=\"https://docs.spring.io/spring-framework/reference/web/webflux.html\">https://docs.spring.io/spring-framework/reference/web/webflux.html</a> )는 스프링(Spring) 5부터 도입된 리엑티브 프로그래밍을 위한 모듈 중 하나입니다.<br>\n리엑티브 프로그래밍은 비동기 동작이고 이벤트 기반의 애플리케이션을 개발하기 위한 패러다임이며, 특히 대규모의 동시성이 필요한 애플리케이션에 적합합니다.</p>\n<p>WebFlux는 다음과 같은 특징이 있습니다.</p>\n<p><strong>비동기 및 논블로킹</strong><br>\n비동기 방식으로 HTTP 요청을 처리하여, 블로킹 I/O 작업이 최소화됩니다. 이를 통해 대규모의 동시 요청을 처리하고 높은 확장성을 제공합니다.</p>\n<p><strong>리액티브 스트림</strong><br>\n리액티브 스트림 API를 사용하여 데이터를 처리합니다. 이 기능은 데이터를 스트림으로 처리하여 실시간 데이터를 처리할 수 있습니다.</p>\n<p><strong>함수형 프로그래밍</strong><br>\n함수형 프로그래밍 패러다임을 따르며, 람다 표현식 및 스트림 처리와 같은 기능을 활용하여 코드를 작성할 수 있습니다.</p>\n<p><strong>다양한 백엔드 런타임</strong><br>\nNetty와 Servlet 3.1+와 같은 다양한 런타임을 지원하고, 선택한 런타임에 맞게 웹 애플리케이션을 개발할 수 있습니다.</p>\n<p>따라서 WebFlux를 사용하면 대규모의 실시간 애플리케이션을 구축할 때 높은 성능 보장과 확장성을 달성할 수 있고, 비동기 및 이벤트 기반 프로그래밍 모델을 활용할 수 있습니다.</p>\n<p>WebFlux는 다음과 같은 장단점이 있으며, Syrup 웹 게이트웨이는 RDBMS와 직접 연동하지 않고, 다른 파트너 사와 연동이 많은 서버임을 고려하여 WebFlux가 적합하다고 판단했습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e10982dcf72a8c05ec297198c75baa25/99072/syrup-05.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.72151898734178%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACAUlEQVR42o1U2W7bQAzU/39PgT70sVAfYqRAE5+SbR3WtbolW/Lt6Q4TuUHRJhFAkNjlDskhKcO2baxWK1DP53OYpgnHceB5HlzXFb1YLOR+uVxivV7D932MRiN5R5s+PN9sNjDoTKDJZCKHeZ5ju92iaRoURSH2brfDbDYTHwZRSiFNU9R1jaqq7n5938NghOl0KqB05GWWZQjDUCLS7rpOgBjQsizx5x19CUy5XC7Y7/cwCDQejwUwiiJ5+PT0S0p6fh4LMLMgAEvmPcsnSJIkEpDvzuczDocDjDCMEAQBGp0+Dxg1imKR4/GI0+kkgGVZCh1DBTz/+5MMlWJWHqJESURSkKah1g7CWEn0OI7vTRqawIwZhJm2bfsH0LK+IIkfYU438OIUURjokr7CcR/w7edaApVlgdvthuv1KjLY5I1C+w5YljZU8oDvEx9OmCDY+DojE673iB+25klnUBQ5PvO9AlaoyhoqLzVXNVLd6TwPkOUxwuSFM47HpwGzLH0hXGuODeePJVGGj80ZyvoQkOSSZI4EN4SkE7iuK+k6Zdv14kyb+n/CeTXei9jTqdHAykXXNnoT9v/0e1uRwbUiTxwZDjHHhDZ1rs8r3ZCuSLQuNB2tjNBbGcaGq8eOCyCFZXNXuVoULj7LaLUjOeQjDjMp4V4P/wC+E1q0HzflNwoMH3Vku4DxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-05\"\n        title=\"\"\n        src=\"/static/e10982dcf72a8c05ec297198c75baa25/f058b/syrup-05.png\"\n        srcset=\"/static/e10982dcf72a8c05ec297198c75baa25/c26ae/syrup-05.png 158w,\n/static/e10982dcf72a8c05ec297198c75baa25/6bdcf/syrup-05.png 315w,\n/static/e10982dcf72a8c05ec297198c75baa25/f058b/syrup-05.png 630w,\n/static/e10982dcf72a8c05ec297198c75baa25/99072/syrup-05.png 842w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>추가로 WebFlux 적용할 때, 성능 향상 이외에 다음과 같은 장점이 있었습니다.</p>\n<p><strong>(1) CompletableFuture를 사용하는 대신, Reactor의 Mono.zip을 활용하면 단순한 비동기 처리가 가능합니다.</strong>\r\nCompletableFuture를 사용하는 경우, thenCombine마다 콜백 함수가 필요하고 콜백 함수에서 이전까지 결과와 현재 결과를 병합하는 코드가 필요해 전체 코드가 복잡해집니다. 반면 Mono.zip을 사용하면 하나의 콜백 함수에서 모든 처리가 가능합니다.</p>\n<p>다음 코드에서 주석 부분은 CompletableFuture를 사용할 때 코드이고, 주석 제거 부분은 WebFlux 사용시 코드입니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static void main(String[] args) {\r\n//    CompletableFuture&lt;String> SK = CompletableFuture.supplyAsync(() ->\r\n//        \"SK\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Planet = CompletableFuture.supplyAsync(() ->\r\n//        \"Planet\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Syrup = CompletableFuture.supplyAsync(() ->\r\n//        \"Syrup\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Development = CompletableFuture.supplyAsync(() ->\r\n//        \"Development\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Team = CompletableFuture.supplyAsync(() ->\r\n//        \"Team\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> future = SK\r\n//            .thenCombine(Planet, (result, planet) -> result + \" \" + planet)\r\n//            .thenCombine(Syrup, (result, syrup) -> result + \" \" + syrup)\r\n//            .thenCombine(Development, (result, development) -> result + \" \" + development)\r\n//            .thenCombine(Team, (result, team) -> result + \" \" + team);\r\n//\r\n//    try {\r\n//        System.out.println(future.get());\r\n//    } catch (InterruptedException | ExecutionException e) {}\r\n\r\nMono&lt;String> SK = Mono.just(\"SK\");\r\nMono&lt;String> Planet = Mono.just(\"Planet\")\r\nMono&lt;String> Syrup = Mono.just(\"Syrup\");\r\nMono&lt;String> Development = Mono.just(\"Development\");\r\nMono&lt;String> Team = Mono.just(\"Team\");\r\n\r\nMono.zip(SK, Planet, Syrup, Development, Team).map(t ->\r\n    t.getT1() + \" \" + t.getT2() + \" \" + t.getT3() + \" \" + t.getT4() + ' ' + t.getT5()\r\n).subscribe(System.out::println);\r\n}</code></pre></div>\n<p><strong>(2) 타임아웃 제한 없이 롱-폴링을 사용할 수 있었습니다.</strong><br>\n기존의 Syrup은 마이데이터 자산 업데이트 체크를 위해 폴링 방식을 사용했습니다. 폴링을 사용하면 프론트엔드에서 매번 업데이트 체크 요청을 전송해야 하므로 고객 네트워크 비용이 증가됩니다.<br>\n이를 개선하기 위해 업데이트 체크 역할을 Gateway로 이전하여 롱-폴링 사용을 고려했으나, 업데이트가 진행되는 기간에 Gateway 서버의 스레드 점유 때문에 서버 비용이 증가되는 문제가 있었습니다. 따라서 롱-폴링을 사용하면, 타임아웃 설정이 필수입니다.<br>\n이번에 WebFlux로 서버를 개편하면서 연결 요청마다 스레드가 생성되지 않는 것을 이용하여 롱-폴링 시 별도의 타임아웃 설정 없이 사용할 수 있었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/832ffa8b102d434ee56cfc36358b464d/cf0be/syrup-06.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.0253164556962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABSElEQVR42oWT666CQAyEff8XhD+IQriLotwFrfmadIPkxLNJ2WV3Op1hy6EoConjWG63m9R1Lb7vS5ZlMgyDHI9HiaJIlmWR1+sleZ4r9vF4CHme52lO27YSBIEkSSIHgH3fK7iqKmmaRpMgYv1+v8UGxCSnaSqXy0VFnE4nJaIIXId1XeV+vyspqq7Xq3Rdp++A9oTzPOuafQoalkJKyAMiOyCmaZLn8ynjOH4RskfY4NywFHKEKEE23wUrWCb4Pr8IcWaWse8sIxc7Zt+q7i3vCTm3PZw5hUgnsG6BBeZfhFssIhwhqraWz+ezBjb+sxyGoeay/rIMENscMEPERe1v2QjZt5uFA6VOIf5NHYT0JPFX22wVkkdP0r8Ud4T0E/0HATZZM+8tQwi2LEsN1mCYXWOTQFVm+72wYATbYVguAQL7LQ3L+QdWS6ECU7O5BwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-06\"\n        title=\"\"\n        src=\"/static/832ffa8b102d434ee56cfc36358b464d/f058b/syrup-06.png\"\n        srcset=\"/static/832ffa8b102d434ee56cfc36358b464d/c26ae/syrup-06.png 158w,\n/static/832ffa8b102d434ee56cfc36358b464d/6bdcf/syrup-06.png 315w,\n/static/832ffa8b102d434ee56cfc36358b464d/f058b/syrup-06.png 630w,\n/static/832ffa8b102d434ee56cfc36358b464d/40601/syrup-06.png 945w,\n/static/832ffa8b102d434ee56cfc36358b464d/78612/syrup-06.png 1260w,\n/static/832ffa8b102d434ee56cfc36358b464d/cf0be/syrup-06.png 1994w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>2. Server Sent Events</h2>\n<p>Server Sent Events(<a href=\"https://docs.nestjs.com/techniques/server-sent-events\">https://docs.nestjs.com/techniques/server-sent-events</a>, SSE)는 서버에서 클라이언트로 단방향 데이터를 전송하기 위한 웹 기술입니다. SSE는 서버에서 클라이언트로 데이터를 푸시하고, 웹 페이지가 열려 있는 동안 데이터를 실시간으로 업데이트할 때 사용됩니다.<br>\n따라서 SSE는 실시간으로 정보가 업데이트 되는 스트리밍 뉴스, 실시간 주가, 온라인 게임, 알림 및 기타 웹 애플리케이션에 유용하게 사용됩니다.</p>\n<p>이러한 SSE의 주요 특징은 다음과 같습니다.</p>\n<p><strong>단방향 통신</strong><br>\n서버에서 클라이언트로 단방향 통신을 제공합니다. 이것은 클라이언트가 주기적으로 서버에 데이터를 요청하지 않고도 서버가 데이터를 보낼 수 있습니다.</p>\n<p><strong>간단한 프로토콜</strong><br>\nSSE는 간단한 프로토콜로써, 웹 브라우저에 내장된 EventSource 객체를 활용하여 쉽게 사용할 수 있습니다.</p>\n<p><strong>Event-Driven 구조</strong><br>\n서버는 이벤트 스트림으로 클라이언트에 이벤트를 보낼 수 있으며, 클라이언트는 JavaScript 이벤트 핸들러를 사용하여 처리합니다.</p>\n<p>SSE를 구현하려면, 서버 측은 특정 HTTP 헤더('Content-Type: text/event-stream')를 사용하여 SSE 스트림을 전송하고, 클라이언트 측은 EventSource API를 사용하여 이벤트를 수신하는 코드를 작성하면 됩니다.</p>\n<p>Syrup은 다음 그림과 같이 SSE를 적용하여 비동기로 호출되는 API 전체 응답을 기다리는 것이 아닌, 개별 API응답을 즉시 프론트엔드에 푸시하고, 프론트엔드에서는 바로 렌더링하여 사용자 경험을 개선했습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1244bef0f52a47d6af9fb577b4ea5cf6/85053/syrup-07.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.12658227848101%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACPklEQVR42n2Ry27TQBSG/YaseBI2PAFsWLNkg4AFCFUQSNWIAAr0RppeaJpekjh2nPgSO059H3smP2cmURVRxEifzmhmzj//OUczTAe/2sewTB0Hwz6et/awc3WD3ZGJlm7i29BAo3eN2vGpon52juZghGZfv+ML8YPesbKE5noePtV3UCfavUsc9If4eXGJz+0OhraD+DaC4AJLAJxzcCFW8S8EnUs02wvxsn6OFx9OMJoGkMuLYhjBHG1y+WZ3H2/3DikeKKesqtSb5XJ5DyU49w10vj7GYeMRPLuLSpATwVXShe3iaW0bT7Y+4tl2A/vUiqpkKwHpSDrbRAp6wQBb3x/iXfMBLLcNWVvFVy6scIFXnVO8PjrB+/Me6idnqB0dY/v0NxrdHlqqzwb1VMeF40nf0GQjL6mhxtQjIYGiKMAYUxREXshYIqPzKMuQyTPKKah0Rq6KNbIV0rlW5DmuaBgjXQejpCRJFGmaIlMkKiZxjDiKVGlYlyyRe4k8V4LjiQPb9RGEEcUQumFjPJlhbLm4MW/R1W9hWD4mtg/T8tSdQXezMMUiyqgqrpDTl0ub+QGmjgt/HiLJOcIox8QJEKclhmMftp/BnNKHiwQ5W1LJgsoXal/QXrraXJpYKwu6kBNOM4bhaExJJbmxES4icufRpzNwNTD5brmK1f8ExUowTgv0rgdI8xIDEvb8Baypq0SVoNiA/0OQr5vM5YQZRxRnymGS5tQzG7NggQkJyrawkibKqjsYq+4J/gHflYWaSPvwEgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-07\"\n        title=\"\"\n        src=\"/static/1244bef0f52a47d6af9fb577b4ea5cf6/f058b/syrup-07.png\"\n        srcset=\"/static/1244bef0f52a47d6af9fb577b4ea5cf6/c26ae/syrup-07.png 158w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/6bdcf/syrup-07.png 315w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/f058b/syrup-07.png 630w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/40601/syrup-07.png 945w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/85053/syrup-07.png 1225w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>3. Next.js</h2>\n<p>Next.js(<a href=\"https://nextjs.org\">https://nextjs.org</a> )는 React 기반의 웹 애플리케이션 프레임워크로써 웹 애플리케이션을 쉽고 빠르게 개발하도록 도와주는 도구와 환경입니다. Next.js는 다음과 같은 주요 기능을 제공합니다.</p>\n<p><strong>서버 사이드 렌더링(Server Side Rendering, SSR)</strong><br>\nNext.js는 기본적으로 서버 사이드 랜더링을 지원하며, 이를 통해 초기 페이지를 로딩할 때 서버에서 페이지를 렌더링하여 검색 엔진 최적화(SEO)와 초기 로딩 속도를 높일 수 있습니다.</p>\n<p><strong>정적 사이트 생성(Static Site Generation, SSG)</strong><br>\nNext.js는 빌드 시 미리 정적 HTML 파일을 생성할 수 있습니다. 이것은 정적 HTML을 우선적으로 노출시켜 초기 로딩 속도 및 사용자 경험을 향상시키고 CDN(Content Delivery Network)을  통한 캐싱도 가능합니다.</p>\n<p><strong>데이터 미리 가져오기(Date Pre-fetching)</strong><br>\n페이지 이동 전에 필요한 데이터를 미리 가져오는 기능을 지원합니다. 이 기능으로 페이지는 빠르고 부드럽게 전환됩니다.</p>\n<p>Next.js는 다음과 같은 장단점이 있으며, Syrup은 Next.js 의 장점만을 수용하여 정적 사이트 생성(SSG)만 적용하기로 했습니다. 서버 사이드 렌더링을 적용하면 별도의 서버 리소스, 모니터링, 운영 인력 등이 필요하기 때문에 서버 사이드 렌더링은 효과 대비 비용 효율성이 떨어진다고 판단했습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9b9c8d200e51dd72e326e5f7d734572b/121b3/syrup-08.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.08860759493672%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABgklEQVR42pWS6Y6CQBCEef+n038ghxeCIKiAIODRztfZMWZDsu4knWnomprq6nGiKJLlcinsxGw2E8/z5HA4SJIkkqapbDYbCcNQgiDQIJ/P54qjvtvtFAvOIVksFuL7voJc19VCHMdKWhSFdF0nWZZpzQpYrVZyPB7ldDopjpzdKctSCQCRN5eLgsghej6fcrvdpKoqjev1qjEMwzsHw+r7XhwK/Hg8HtKbvNin0rWtDOMoownW/X7X1j7tWa/Xst1utRPUIUAVjj8HARTmZ00YJXvTIkAW9bqu9UDTNHo5qgkusxwX091bIUAkY7gdBGZbQg7/tbTl8/msclGDZxBbX6w3/yJkAEwZZbTN1HkaeZ5La7ykDYBfE+INpAQqIULl5xTJvyakXdRZhVYlxfdzMIRMnW+GMBUMCsscDqKA3eYU8I2dyVdZLFWeSGk6QDFqwf0OVTglnRs5iIdZlss+ciUNXcmMHV3Xag3M1JokhAiFHGIonh9o8CJozXYxRfgCRs7mFYAXR5QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-08\"\n        title=\"\"\n        src=\"/static/9b9c8d200e51dd72e326e5f7d734572b/f058b/syrup-08.png\"\n        srcset=\"/static/9b9c8d200e51dd72e326e5f7d734572b/c26ae/syrup-08.png 158w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/6bdcf/syrup-08.png 315w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/f058b/syrup-08.png 630w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/40601/syrup-08.png 945w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/121b3/syrup-08.png 1070w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h1>개선 과정에서 시행착오(WebFlux 위주)</h1>\n<p>WebFlux를 적용하면서 겪었던 몇 가지 시행착오를 정리해 보았습니다.</p>\n<p>첫 번째는 리액티브 프로그래밍 모델에 대한 적응이 필요했습니다.<br>\n예를 들어 다음 코드에서 getSummaryBad 함수가 실행되어도 실제 System.out.println(res); 구문이 실행되지 않았는데 이유가 무엇일까요?</p>\n<p>이유는 (1)리엑티브 프로그래밍 모델은 발행자(Publisher)-구독자(Subscriber) 모델이 사용되는데 별도 구독을 하거나 하나의 구독 파이프라인 안에서 실행되고, (2)발행자의 발행 준비가 완료된 후, 푸시되어야 구독이 일어나기 때문입니다.</p>\n<p>Mono.just를 사용하면, 즉각적인 발행이 이루어지므로 발행은 별개로 하고, getSummaryBad는 별도의 구독도 없고 파이프라인에도 포함되지 않아 System.out.println(res); 구문이 실행되지 않았습니다. 그리고 getSummaryNormal은 구독 파이프라인에 포함되어 로그가 출력되는 차이가 있습니다.</p>\n<p>이와 같은 우리는 리엑티브 프로그래밍 모델에 대한 적응이 필요했으며, 리엑티브 시스템의 기본 개념, 리엑티브 프로그래밍 모델, 리엑터 라이브러리의 사용법 등을 익히는 데 6개월 이상 소요되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">private Mono&lt;String> getToken() {\r\n    return Mono.just(\"token\");\r\n}\r\n\r\nprivate Mono&lt;String> getMember() {\r\n    return Mono.just(\"member\");\r\n}\r\n\r\nprivate Mono&lt;String> getMembershipInfo() {\r\n    return Mono.just(\"membership\");\r\n}\r\n\r\n// reactive programming bad example\r\npublic Mono&lt;ServerResponse> getSummaryBad(ServerRequest request) {\r\nMono token = getToken();\r\nMono member = getMember();\r\n\r\ntoken.flatMap(res -> {\r\n    System.out.println(res);\r\n    return res;\r\n});\r\n\r\nmember.flatMap(res -> {\r\n    System.out.println(res);\r\n    return res;\r\n});\r\n\r\nMono membership = getMembershipInfo().flatMap(res -> {\r\n    return Mono.just(res);\r\n});\r\n\r\nreturn ServerResponse.ok().body(membership, String.class);\r\n}\r\n\r\n// reactive programming normal example\r\npublic Mono&lt;ServerResponse> getSummaryNormal(ServerRequest request) {\r\n    return token.flatMap(tokenRes -> {\r\n        System.out.println(tokenRes);\r\n        return member.flatMap(memberRes -> {\r\n            System.out.println(memberRes);\r\n            return getMembershipInfo().flatMap(membershipRes -> {\r\n                return ServerResponse.ok().body(Mono.just(membershipRes), String.class);\r\n            });\r\n        });\r\n    });\r\n}</code></pre></div>\n<p>두 번째는 멀티 스레드 기반 라이브러리를 사용할 수 없습니다.<br>\nWebFlux는 스프링 MVC와 다르게 연결 요청마다 별도의 스레드를 생성하지 않기 때문에 스레드 기반으로 데이터를 관리하는 라이브러리를 사용할 수 없습니다.  만약 이것을 무시하고 사용하면 다른 사용자의 정보가 노출되는 지옥이 펼쳐질 수 있습니다.</p>\n<p>대표적인 멀티 스레드 기반 라이브러리는 ThreadLocal, MDC(Mapped Diagnostic Context) 등이 있으며, 이를 대체하기 위해 WebFlux는 ContextView를 제공합니다. 또한 로그 추적을 위해서 Spring Cloud Sleuth를 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// context write\r\n.contextWrite(context -> {\r\n    context = context.put(ContextType.MEMBER_CONTEXT, MemberContext.builder().build());\r\n    return context.put(ContextType.LOG_CONTEXT, LogContext.builder().traceId(TraceUtil.createTraceValue()).build());\r\n})\r\n\r\n// context read\r\n    return Mono.deferContextual(contextView -> {\r\n        MemberContext memberContext = (MemberContext) ContextUtils.getContext(contextView, ContextType.MEMBER_CONTEXT);    \r\n});</code></pre></div>\n<p>세 번째는 블로킹 라이브러리를 사용할 수 없습니다. 언급한 바와 같이 WebFlux는 스프링 MVC와 달리 연결을 요청할 때마다 스레드를 할당하지 않고, 적은 수의 Worker 스레드를 공용으로 사용하는 리액티브 프로그래밍 모델입니다.</p>\n<p>이처럼 적은 수의 Worker 스레드를 사용하기 때문에 스프링 MVC에서 사용하던 블로킹 라이브러리를 그대로 사용하면, 전체 시스템이 블로킹될 수 있습니다. 참고로 RestTemplate은 대표적인 블로킹 I/O를 사용하는 라이브러리입니다.</p>\n<p>만약 RestTemplate을 이용하여 API 호출 중 대기시간이 길어질 경우, 스프링 MVC는 해당 API만 영향을 주지만 WebFlux는 전체 시스템에 영향을 주게 됩니다.</p>\n<p>WebFlux에서 대표적으로 사용할 수 있는 논-블로킹 라이브러리는 다음 그림과 같으며, 이 중에서 R2DBC(Reactive Relational Database Connectivity)는 아직까지 지원 데이터베이스 부족, 커뮤니티와 지원 부족, 개발의 복잡성 등의 문제가 있기 때문에 신중히 사용해야 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/98e0538075e2c6d9c021f274bae652ce/6937a/syrup-09.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.45569620253164%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACXklEQVR42l1T21LiUBDk/39i191yXyzvqw+WosQLyKKgorkAMQkEciMEIsG33umDsdZNVdc5mTBNz0xPJc9zzGYzuK6r4HkeRqMRsizDcrkEn346w8mri6rjYee+je27NvYfuthqtrBz18FJb4BTd4jWJECFSYvFAr7vIwgCjMdjdWds9f6uCMeLHK1xgLZAMyyFuu3g0uyhpptoDX3cTUJYSYpKURR4e3sDzzAMEUWRulP5/4SdIMKjJPEkWVNUPU1n6ISxqBPCqRCSjMks0TAMmKap7owVq5UitGcZqpKsiRJtOEbVdrHVaOKo+6LeGT/3RmjLH1VKNSReCcG7qGIbStWF3JNlAT1OpKQpDDn1MEIvzZQivpsS53cvm6PCXs3ncwUqtCwLZYxnLid7czRwpPEj/DZ6+H6h4ddNAxsXl9huP+DUGeJYvt/6E1So6lPNP6BKlpznC8TSw4FM+lVKd0QFz0+k61hf1LLXSiEJOVld1xU4acbWCjOY8uPDno3N+i02tGt8E2U/rxv4cVXHZuMPNmpX2NMt3MpgvvSwLJX3UvVKkIja5yjGi/SuK0nslx6tYUj/noMQXfnmsockI2iZ0txxHCvypZDxYbmnYuoL6eHh0zN2xcz7nUeFXTH5mXiyKlO+p8JyotwWbggxnU7XPvywjfKhL8aWhPrgFZqY+aZvK9CPX4xNQibT0CRKkgRpmn4x9lDawAky6VpWkKjJutWsPjQhbcq3phif5auSWR532HEc2Lb9uXrFR8l92YYzsYbm+Tju6jj4KHXvvoOD9iPOueeur4z9F0PDt74G7gYBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-09\"\n        title=\"\"\n        src=\"/static/98e0538075e2c6d9c021f274bae652ce/f058b/syrup-09.png\"\n        srcset=\"/static/98e0538075e2c6d9c021f274bae652ce/c26ae/syrup-09.png 158w,\n/static/98e0538075e2c6d9c021f274bae652ce/6bdcf/syrup-09.png 315w,\n/static/98e0538075e2c6d9c021f274bae652ce/f058b/syrup-09.png 630w,\n/static/98e0538075e2c6d9c021f274bae652ce/40601/syrup-09.png 945w,\n/static/98e0538075e2c6d9c021f274bae652ce/6937a/syrup-09.png 1094w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Syrup 웹 게이트웨이는 리액티브 환경에서 외부 API 연동을 위해 WebClient를 사용하며, MemCached 사용을 위해 com.spotify.folsom(<a href=\"https://github.com/spotify/folsom\">https://github.com/spotify/folsom</a> )을 사용합니다.</p>\n<p>네 번째는 스프링 MVC에 비해 생태계가 작기 때문에 사용할 수 있는 라이브러리의 선택지가 좁습니다.</p>\n<p>Syrup은 다음 그림과 같이 A 서버에서 MemCached에 값을 저장하고, B 서버에서 MemCached의 값을 읽어서 사용하는 경우가 있습니다. A 서버와 B 서버가 동일한 라이브러리 패키지와  Key 해싱 알고리즘을 사용한다면, 다중 노드를 사용하더라도 문제 없이 동작됩니다(캐시 HIT).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 526px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c171ced0f1e6cb0d17e222a64509866e/2d7ab/syrup-10.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.60759493670886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtUlEQVR42n2QW29SURCF+Y8++GLik/4DH3wy/gdNTAzkIFfBRl+ItDakrRQ45V4ol0JpoUDxtJKCUjmcy+dwhIb0wUlmT/aatddeMy42wjBNCoMrsv0r8lLzwxE7pWN2y1W+SU2c1B0sJz31ckh1pGHb9qYEruWxhu70BfH2BYFqA+W4hq9Sx6PmeJvM8CaZRskW+CDYshc8aXLQ7bMwjP8ILhZ8bXV4sXvAY2+IZ59jvP6e4Wn0C0+CUV7tp3gu2CO3j5fCOez10R8KLh2vbeuGSfpygL9Y4Z24UrJFPsq4748KuHMlopUaXul58mUiMkVRxl+uafn+X64cruPmWkPTRtiWufJtY5kGpjg39DnGYi6Yxa/pLb3eOd3xjLnxYIfb2x2i0RKRSAGv9xBFSbK1VSYQUNnbu8AwrHtyufyDcLhEMKji9uyj+DLyrij3I2KxGrpu4UokBiJQIhRSRTjvVL8/5dREos9w+NsRm0z+kEppzmfhsHA/FQgF0yKWkc9TxOMdut0prrOzKa3WT5rN6/us10ecnt7Qbk8Yj+8cwdlMp9OZrLjaBlej0dCEeyvrmvEX3Rc3dMgH7/gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-10\"\n        title=\"\"\n        src=\"/static/c171ced0f1e6cb0d17e222a64509866e/2d7ab/syrup-10.png\"\n        srcset=\"/static/c171ced0f1e6cb0d17e222a64509866e/c26ae/syrup-10.png 158w,\n/static/c171ced0f1e6cb0d17e222a64509866e/6bdcf/syrup-10.png 315w,\n/static/c171ced0f1e6cb0d17e222a64509866e/2d7ab/syrup-10.png 526w\"\n        sizes=\"(max-width: 526px) 100vw, 526px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>하지만 WebFlux는 블로킹 I/O를 사용하는 com.whalin.MemCached를 적용할 수 없었고, 논-블로킹 I/O를 사용하는 com.spotify.folsom을 사용해야 합니다.</p>\n<p>두 라이브러리가 지원하는 Key 해싱 알고리즘이 다르기 때문에 다음 그림과 같이 다중 노드 환경에서 캐시 Miss가 발생됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f6d07432201f97448a8e1fe27c5d54d6/29492/syrup-11.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB1ElEQVR42lWRS3MSURCF+ZVWudG9rix/ge5dpFyk4gISSZAqXIQQggwR0IDAAAkMFcJzEocwDAOWyPuR4fM6JhZ2Vdft7tv3nNO3HQhb89fG8zkp7ZZMq01WN/hab+JPy4QLCgE5R7zWINvuIN/qpEVPTpyL1YpNc9iA94jmaEywecOHyyr7ZeFKmb3sOe8yeXbSObzKJR5x5xbuvaoRudYYzmZsinJsJr3RiMOayotwlMfvvTz3f+J1Quap75AnHh+vvnzjWUDikeuAl0GJzzcthtPp/4CWtebubm1Xfk3nnKrf2RaK3sQS7MjnuAsl3qaybCVS7OWLbIvaVjKD60Ih2dKZLJc2kHU/puNh9rUo/OibDIY/RbyyOddri+VqKXxl+0I8XiwWWJZFt9ej025DxwAx2b8/jERUQqErjo9LeDxJPvrEEsIV/EcKuZxuEz1Yt9ulWq2KulhQPM6pJCFHo1yk09TrdcbjMY5AoInbnWZ3N8n+gYzTdYbTeWbnkqTRNcc22GQ6o95oUFQUorGYIA0TPDkhJIXtvFwuo+s6jmp1gKJ0KBTaFIu6febzGqWSQaUyoN+f2IAzsc0/Cg3DQNM0VFW11TYEybWITdMUvX1+Aw93OJKaLjMkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-11\"\n        title=\"\"\n        src=\"/static/f6d07432201f97448a8e1fe27c5d54d6/29492/syrup-11.png\"\n        srcset=\"/static/f6d07432201f97448a8e1fe27c5d54d6/c26ae/syrup-11.png 158w,\n/static/f6d07432201f97448a8e1fe27c5d54d6/6bdcf/syrup-11.png 315w,\n/static/f6d07432201f97448a8e1fe27c5d54d6/29492/syrup-11.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>결국 특정 라이브러리를 사용할 수 없어서 기존 로직을 변경하거나 다른 우회적인 방법을 찾아야 하는 시행착오를 겪었습니다.</p>\n<h1>개선 결과</h1>\n<p>WebFlux, Server Sent Events, Next.js를 통한 웹 게이트웨이와 웹 서버를 개선한 이후, Syrup의 전체적인 화면 로딩 속도가 개선되었습니다.</p>\n<p>(1) API 요청 건수는 기존 대비 70% 이상 줄었습니다. 개별로 호출되던 API가 하나의 API로 통합된 결과입니다.</p>\n<p>(2) API 응답 속도는 기존 대비 50% 이상 개선되었습니다. 순차적으로 호출되던 외부 API가 비동기로 호출된 결과입니다.</p>\n<p>(3) API 이외에 Next.js 적용을 통한 렌더링 속도 개선 효과도 확인할 수 있었습니다.<br>\n또한 LightHouse를 통한 웹 페이지 성능을 확인해 보았는데요. 특히 이번 개선으로 First Contentful Paint, Total Blocking Time, Speed Index 값이 개선된 것을 확인할 수 있었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3272365d2a7412071f93309caa3150c4/d74fe/syrup-12.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5ElEQVR42o1S2Y6bQBDk/38pUh7y4sS70fpY21zDbVguc83AcNiVHuKVNm9BahVT01R3Na0VRYE4jpEkCdI0RXS9rnGNE9jMQeD78IMAuq4jDHxcdjvsfv+Aa7zh2+Y7Xt9eoRsGzuczLMuCxhjD6XTC/nCAZRpwmAVmW/DZBfr7C5jjwqTkI927lOvRRxZz4YUh9sc9XLoPKCzDRBRF0FRlJfhru8X5uIOsEwxFhCLVYXgv4GJG6W5RfkTIywyH9w3SOIOXOvh52aCpOG7hEVlgoGk5NJ8s2bYN1WlIVYdhwDiO6ITAra3pLMF5iV50xHHkTQnBBWpOQk2Flg9UtEbTNeh4D03NTwkpQdXy4/GAehT+E09OUoFRDphihnt7w5Q4WNoSY3ZFX5f/L0jMiqLvMZGDuc6x9BwTdbyIFq17QZvF0Az6Q2qGnuetwj1ZHaVcrUsV1I06q/eVJ0HFDeMEScKf2Ek1JrKsRNQcHcchwQi8J0vzTLFQ4oRGSHTDjJb4rv+CYniiJG6mXJolb6ApmyHtmWma8KlLkYaYeI2pSrFQQp8nNBv6OcUT86/YrLyg85QH4AVZVgutuoxpkTNa7OlqY6H5zKmLucoIPToTfni4KyT+E5fm7/29TjEnDLLK8Qfyc+3S2905rQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-12\"\n        title=\"\"\n        src=\"/static/3272365d2a7412071f93309caa3150c4/f058b/syrup-12.png\"\n        srcset=\"/static/3272365d2a7412071f93309caa3150c4/c26ae/syrup-12.png 158w,\n/static/3272365d2a7412071f93309caa3150c4/6bdcf/syrup-12.png 315w,\n/static/3272365d2a7412071f93309caa3150c4/f058b/syrup-12.png 630w,\n/static/3272365d2a7412071f93309caa3150c4/40601/syrup-12.png 945w,\n/static/3272365d2a7412071f93309caa3150c4/d74fe/syrup-12.png 1164w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>(4) 마지막으로 실제 앱 실행을 통한 비교 시험에서도 성능이 좋아진 것을 확인할 수 있었습니다.<br>\n개선 전(3.52s) 대비, 개선 후(1.96s) 최초 로딩 속도가 1.56s 개선되었습니다.</p>\n<h1>마무리</h1>\n<p>지금까지 Syrup 모바일 웹의 몇 가지 개선 사례를 공유 드렸습니다. 개선 과정에서 WebFlux, Server Sent Events, Next.js를 활용한 성능 개선에 집중했고, 실제로 체감할 수 있는 성능 향상을 달성했습니다.</p>\n<p>이러한 결과를 얻기까지 WebFlux, Server Sent Events, Next.js를 도입에 따른 레퍼런스 부족, 코딩스킬 경험의 부족으로 인한 여러 시행착오의 과정을 겪었지만 그 결과 실질적인 성능 향상 뿐만 아니라 개발 관점에서 많은 성장과 다양한 경험을 할 수 있었습니다.</p>\n<p>짧은 글이나마 과정을 정리한 이 글이 독자 여러분의 성장에 작은 밑거름이 될 수 있길 바랍니다.</p>\n<p>감사합니다.</p>\n<p>모으는 재미, 불리는 맛 Syrup</p>\n<p>Google play<br>\n<a href=\"https://play.google.com/store/apps/details?id=com.skt.skaf.OA00026910&#x26;hl=ko&#x26;gl=US\">https://play.google.com/store/apps/details?id=com.skt.skaf.OA00026910&#x26;hl=ko&#x26;gl=US</a><br>\nApple App Store<br>\n<a href=\"https://apps.apple.com/kr/app/syrup-%EC%8B%9C%EB%9F%BD/id430282710\">https://apps.apple.com/kr/app/syrup-%EC%8B%9C%EB%9F%BD/id430282710</a></p>","frontmatter":{"title":"Syrup 모바일 웹 속도 개선기: WebFlux, SSE, 그리고 Next.js","date":"December 12, 2023","description":"모으는 재미, 불리는 맛 Syrup, SK플래닛의 대표 서비스 Syrup의 웹 개선 사례를 소개합니다.","author":"changho"}},"previous":{"fields":{"slug":"/branding-wezuro/"},"frontmatter":{"title":"SK플래닛 신규 서비스 Wezuro 브랜드 구축 스토리"}},"next":{"fields":{"slug":"/rbarhis-ai/"},"frontmatter":{"title":"ARHIS: 음향 기반 도로 노면 검지 솔루션"}}},"pageContext":{"id":"16e67e25-766e-516f-b9dd-83025319d7ab","previousPostId":"ca7feacf-bb24-513d-b31f-ee6952b60c5a","nextPostId":"8a318d25-f309-5c13-a94a-860bf2627840"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}