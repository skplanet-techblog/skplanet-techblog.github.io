{"componentChunkName":"component---src-templates-blog-post-js","path":"/chatdic-fe-blog/","result":{"data":{"site":{"siteMetadata":{"title":"SK플래닛 TECH TOPIC"}},"markdownRemark":{"id":"c9362c21-0ba0-5b2d-9929-5ea1e377c5bf","excerpt":"이 글은 SK플래닛 Chat DIC 사내 프로젝트의 프런트엔드(Frontend) 개발 과정에서, 실시간 대화형 LLM 서비스의 특성에 맞춰 적용한 여러 기술적, 성능적 개선점을 정리한 글입니다. Chat DIC(저희는 /챗:디/라고 읽습니다)는 SK플래닛 Data Infrastructure팀에서 개발한 Text 기반의 SQL Assistant 및 Table…","html":"<p>이 글은 SK플래닛 <strong>Chat DIC 사내 프로젝트의 프런트엔드(Frontend) 개발</strong> 과정에서,<br>\n실시간 대화형 LLM 서비스의 특성에 맞춰 적용한 여러 기술적, 성능적 개선점을 정리한 글입니다.</p>\n<p><a href=\"https://techtopic.skplanet.com/chatdic-ai-text2sql/\"><strong>Chat DIC</strong></a>(저희는 /챗:디/라고 읽습니다)는 SK플래닛 Data Infrastructure팀에서 개발한 <strong>Text 기반의 SQL Assistant 및 Table 메타 검색 시스템</strong>입니다.\n이 글에서는 Chat DIC의 프런트엔드에 도입된 기술 중 주요 항목을 소개합니다.</p>\n<p>(참고) 프런트엔드 vs. 프론트엔드: 어떻게 쓰는 게 맞을까요? 에 대한 답변은,  <br/>\n국립국어원 답변에서는 <strong>'프런트엔드'</strong> 가 맞다고 하며, 실제 위키백과나 구글 트렌드 등에서는 <strong>'프론트엔드'</strong> 표현이 더 많다고 합니다. 참고로 다음 글도 함께 읽어보세요(<a href=\"https://www.inflearn.com/blogs/2544?srsltid=AfmBOopiLr3H07bm32c0UeJT52CnuCFh0HGsh8czkumC81ag5tHU8m4O\">인프런 글</a>). <br/>\n(저희 다른 글에서도 혼용되어 있을 텐데 가급적 하나의 글에서는 동일한 표현을 유지하려고 노력하고 있습니다. 이 글에서는 <strong>'프런트엔드'</strong> 로 정리해 보았습니다)</p>\n<blockquote>\n<p>Chat DIC 프런트엔드는 React + Vite + JavaScript로 개발되었으며, <br/>\nTailwind CSS 기반의 UI 라이브러리를 사용하고 있습니다.</p>\n</blockquote>\n<br/>\n<h3>Chat DIC 로그인 화면</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c7b1f11a5668c36fe20c16d7ac46a7e2/5068c/chatdic_login.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.93670886075949%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3UlEQVR42p2SywqDMBBF/f9v6T90UdSFVqxdlEKRxqK22IXvIprcOgHFV5GacHFyQ46TmSiYDEFTTLzWKIoSeV6sSpkBBTD3NgCF4PLLbjvc2akHDYFZlv8PvFz3OBytRWCnsvxIOInizh8B67qG67oIghcC34fnsR7IuZAHo+gN3w8Qhs92/wHGPBmTR3sE7YGc8/ZQ2We6VMM0zRDHCZIklTGJ4m49yrCqKqiqCk3ToOs6LMuSP1lryrAUsyvbtg3TNGEYBhznPKvhpmczHJQhqWka2YDumqRfHf8CBSW3q6+3j14AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chatdic_login.png\"\n        title=\"\"\n        src=\"/static/c7b1f11a5668c36fe20c16d7ac46a7e2/f058b/chatdic_login.png\"\n        srcset=\"/static/c7b1f11a5668c36fe20c16d7ac46a7e2/c26ae/chatdic_login.png 158w,\n/static/c7b1f11a5668c36fe20c16d7ac46a7e2/6bdcf/chatdic_login.png 315w,\n/static/c7b1f11a5668c36fe20c16d7ac46a7e2/f058b/chatdic_login.png 630w,\n/static/c7b1f11a5668c36fe20c16d7ac46a7e2/40601/chatdic_login.png 945w,\n/static/c7b1f11a5668c36fe20c16d7ac46a7e2/78612/chatdic_login.png 1260w,\n/static/c7b1f11a5668c36fe20c16d7ac46a7e2/5068c/chatdic_login.png 1917w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>Chat DIC 대화 화면</h3>\n<h2><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cbaf4a36507d7e67ade421e6364c6aa3/9b29b/chatdic_hello.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.734177215189874%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwElEQVR42qVS0Q6DIBDz/7/PF/c29QGN0YgICkLnsWDchm6LTRpykJYeXOKcwzvPQOfWWs+9hmpjDJKYQAiBYRgwjiOUUp5SSk8SLcsCrU30wiS2ec9zZNkNjLEXk5DsDFFDMiqKAk3ToG1bzPOMXxE1rOsaZVmCc45/cWiYr23TSu9JbX/7rFNDrbV/MzKhlXgp4RVEx6bve58yzFhI6ZzdOjj6qA9DEqZp6kWhllJhmqZ1ZJ6td12Hqqq2AHvDB9kHFcdRDkLSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chatdic_hello.png\"\n        title=\"\"\n        src=\"/static/cbaf4a36507d7e67ade421e6364c6aa3/f058b/chatdic_hello.png\"\n        srcset=\"/static/cbaf4a36507d7e67ade421e6364c6aa3/c26ae/chatdic_hello.png 158w,\n/static/cbaf4a36507d7e67ade421e6364c6aa3/6bdcf/chatdic_hello.png 315w,\n/static/cbaf4a36507d7e67ade421e6364c6aa3/f058b/chatdic_hello.png 630w,\n/static/cbaf4a36507d7e67ade421e6364c6aa3/40601/chatdic_hello.png 945w,\n/static/cbaf4a36507d7e67ade421e6364c6aa3/78612/chatdic_hello.png 1260w,\n/static/cbaf4a36507d7e67ade421e6364c6aa3/9b29b/chatdic_hello.png 3840w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></h2>\n<h1>주요 내용</h1>\n<ul>\n<li>SSE(Server-Sent Events)를 이용한 실시간 스트리밍 처리</li>\n<li>Buffer 적용으로 대화 출력 성능 개선</li>\n<li>Virtualization(가상화) 기반 Windowing 기법 적용</li>\n</ul>\n<hr>\n<h1>SSE(Server-Sent Events)로 구현한 실시간 대화 스트리밍</h1>\n<p>일반적으로 채팅 형식의 애플리케이션을 구현할 때는 <strong>WebSocket</strong>을 이용한 양방향 통신 로직을 먼저 구현해야 할 것으로 생각합니다. 그러나 LLM에서는 응답을 <strong>서버 → 클라이언트 단방향</strong>으로 전달하기 때문에 WebSocket처럼 복잡한 양방향 통신 기능이 불필요합니다.\n사용자 요청은 단순한 HTTP만으로도 충분하며, 클라이언트는 서버의 응답을 실시간으로 스트리밍하면 됩니다.</p>\n<p>따라서 많은 LLM 애플리케이션들은 <strong>SSE(Server-Sent Events, 이하 SSE)</strong> 방식을 주로 채택하고 있으며, Chat DIC의 프런트엔드에서도 SSE 방식을 적용하여 스트리밍을 구현했습니다(SSE는 IE를 제외한 대부분의 브라우저에서 지원하고 있습니다).</p>\n<h3>비교: WebSocket vs SSE</h3>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>WebSocket</th>\n<th>SSE(Server-Sent Events)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>통신 방향</td>\n<td>양방향 (Client ↔ Server)</td>\n<td>단방향 (Server → Client)</td>\n</tr>\n<tr>\n<td>프로토콜</td>\n<td>ws://, wss://</td>\n<td>HTTP/HTTPS</td>\n</tr>\n<tr>\n<td>재연결 처리</td>\n<td>수동 구현</td>\n<td>브라우저가 자동 처리</td>\n</tr>\n<tr>\n<td>데이터 형식</td>\n<td>바이너리/텍스트</td>\n<td>텍스트(JSON 등)</td>\n</tr>\n<tr>\n<td>방화벽 통과</td>\n<td>어려움</td>\n<td>용이</td>\n</tr>\n<tr>\n<td>서버 구현 복잡도</td>\n<td>높음</td>\n<td>낮음</td>\n</tr>\n<tr>\n<td>HTTP/2 호환성</td>\n<td>제한적</td>\n<td>완전 지원</td>\n</tr>\n<tr>\n<td>주요 사용 사례</td>\n<td>채팅, 협업 도구</td>\n<td>알림, LLM 응답 스트리밍</td>\n</tr>\n</tbody>\n</table>\n<p>SSE는 일반 HTTP 통신과 달리 서버로부터의 데이터 전송이 모두 완료될 때까지 Connection을 유지하는 게 특징입니다.\n그리고 Connection Error가 발생하면 브라우저 차원에서 자동으로 재연결을 시도합니다.</p>\n<h3>HTTP vs HTTP w/SSE</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d0a89187ea8f873fad4ed1277aeac6ba/0b533/HTTP_vs_HTTP-wSSE.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.8987341772152%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADW0lEQVR42o1UWU8bSRCe//+EkHgJLwQSgXhA8ICCVosSJSixwdjGJz7whT1je07PPT1jf6lqry0SxbvbUql7aqqrvqr+qpTVaoVdwkvXdVxfX+Py8hIXFxcIgkDqd91RsGNtHBqGgXwuh0qlgnK5hCRJ8G9LSRJBUWMEYbzeSZbL1dYgjATsRQg/SMgmwT9xkGVLeKTzQwGPxKVznKRQ6gMDdzUVLc2H6gh0NI9+xliRU3vhYzieo/j0gqdaD63uGHN9gdHrHKYT4FvpBYXGEKOZjd7EQF9zoIynNiYzByahcLwYI9WCEJlEEUUUNRZIswwiXYvnRzDMBQwnROEhj+rDZ9RLdyjnv6DTV6E4hEKkqazZcrmEZbsyLdYJkWKmO6g2BngmdM+dMdhePhYhbDWb6NUKaFULqBXv0SPkSqmt4e/CAE8DG/15gErfhE91My0X9daI0LiYTE2MxjrGqiEDBEGEueXjr29l3OWe0O72UG920BqSQ4tSVefrFCw3kqlzam9f+k+LH0CzQsycBFaQwfRTqr3YTZu39NnF0T/Shv9t6sfyXxc3us2dtR22+/9C+Bbp7+ffs5AOuZ00TYOqqnBdF77vSwnDkKgT/eKY9RnRiNGxrRBC6rmDtg6vrq5weHiIk5MTnJ+fY29vD/v7+zg7O5M79/DR0RFubm5wenqKd+8OcXx8LO2P3r/Hhw8fcXBwgNvb27XDNBUyAkfj6FEUbhEyCs7A8zypFyKROvkdBggDyobOvsd2PhTuR8eP4b7pyYzS2SyD+FhtDtHta5KLsmOokxLanTCDG69AbIEvVojEEkqhqeJTrotSz0R36qHSM7DwItn8cyLxTLehzSy8TnRJ6snUIiKPMTN9fPp8j68/Hum7Q8R+RpuJ7SwCJBQxzVYUfQnT9rfThicQo0nTtfAkimk68Vm3A9QaDbQbRdSrRZRLBXRH5FCbEwrDxYLTpgs8LNKMX5DakHo4X2yjWHlB7XmIMk0cPnd6E0xNDw/5Aqr5O9Qf8yjmvqM7mEIptjTcPg5RHToYzEPUhrZ0rmomdJoqJg0LriMLn1nHA0IjEF/yTdyXWxi8alTjMfo0qZTNaEposmyE+cSXLduD7fi/CpWEy8T3EipTQm1PbQ2acrJkPwF77uZzcqH5WAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"HTTP_vs_HTTP-wSSE.png\"\n        title=\"\"\n        src=\"/static/d0a89187ea8f873fad4ed1277aeac6ba/0b533/HTTP_vs_HTTP-wSSE.png\"\n        srcset=\"/static/d0a89187ea8f873fad4ed1277aeac6ba/c26ae/HTTP_vs_HTTP-wSSE.png 158w,\n/static/d0a89187ea8f873fad4ed1277aeac6ba/6bdcf/HTTP_vs_HTTP-wSSE.png 315w,\n/static/d0a89187ea8f873fad4ed1277aeac6ba/0b533/HTTP_vs_HTTP-wSSE.png 500w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span> <br/></p>\n<p>또한 클라이언트의 상태를 서버에 지속적으로 알려주며 트랜잭션 부하를 일으키는 Polling 방식과는 달리, SSE는 한 번의 트랜잭션 내에서 데이터 처리가 가능하다는 장점이 있습니다.</p>\n<p>그리고 무엇보다 중요한 것으로, SSE는 WebSocket보다 구현이 <strong>쉽습니다</strong>.</p>\n<h3>SSE를 활용한 스트리밍 응답 처리</h3>\n<p>다음으로 SSE를 활용한 서버의 스트리밍 응답을 처리하는 방식에 대해 설명드리겠습니다.\n스트리밍 응답 처리는 <a href=\"https://developer.mozilla.org/en-US/docs/Web\">MDN</a>에서 제공하는 웹 표준 가이드 문서들을 바탕으로 구현했습니다.</p>\n<h3>서버로부터 스트리밍 응답 받기</h3>\n<p>먼저 사용자의 메시지를 REST API 호출을 통해 서버에 전달합니다.\n그러면 서버에서는 Content-Type이 <code class=\"language-text\">text/event-stream</code>인 HTTP 응답을 리턴합니다.\n브라우저에서는 이를 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/ReadableStream\">ReadableStream</a> 객체로 받습니다.</p>\n<p>서버와의 통신은 JavaScript의 기본 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Using_Fetch\">Fetch API</a>를 사용하여 구현했습니다.</p>\n<blockquote>\n<p>Fetch API를 사용하기 전, 저희팀에서 JavaScript 개발자들이 자주 사용하던 <a href=\"https://axios-http.com/kr/docs/intro\">axios</a> 라이브러리를 적용해 보았습니다만,\n해당 라이브러리는 스트리밍 응답 처리에 적절하지 않음을 확인하였습니다.\n왜냐하면 axios는 브라우저에서 실행시 XMLHttpRequest 객체를 사용하여 request를 처리하며, 응답을 ReadableStream 객체로 리턴하지 않기 때문이었습니다.</p>\n</blockquote>\n<h3>스트리밍 응답 파싱하기</h3>\n<p>Content-Type이 <code class=\"language-text\">text/event-stream</code>인 서버 응답은 일반적인 HTTP 응답과 좀 다릅니다.\n해당 응답은 Event Stream이라는 포맷을 따르며, 각 메시지는 <code class=\"language-text\">data:</code> 접두어로 시작하는 데이터 블록으로 구분됩니다.</p>\n<p>아래는 Chat DIC 서버로부터 받은 스트리밍 응답의 일부입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"event-stream\"><pre class=\"language-event-stream\"><code class=\"language-event-stream\">data: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot;안녕하세요!&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot; 저는 D&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot;IC(Data&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot; Integration&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot; Cluster&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot;)&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot; &quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot;빅데이터 시&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot;스템의&quot;}\n\ndata: {&quot;type&quot;: &quot;message&quot;, &quot;content&quot;: &quot; &quot;}\n\n...\n\ndata: [DONE]</code></pre></div>\n<p>브라우저에서는 이를 ReadableStream 객체로 받게 되며, 이를 파싱하여 각 데이터 블록을 추출 및 처리하여 실시간으로 화면에 출력해야 합니다.\n스트리밍 응답을 파싱하는 로직은 MDN의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\">ReadableStream</a> 문서에서 소개하는 예제를 바탕으로 구현했습니다.</p>\n<h3>스트리밍 응답 출력 결과</h3>\n<p>아래 영상에서 Chat DIC 서버에서 받은 스트리밍 응답이 실시간으로 브라우저에 출력되는 모습을 확인할 수 있습니다.<br/>\n<img src=\"/b5503982fbacac14a05c70d03eb6f1c0/SSE_Streaming.gif\" alt=\"SSE_Streaming.gif\"></p>\n<p>결과적으로 Chat DIC에서는 SSE를 도입함으로써 <strong>더 적은 코드로 안정적인 실시간 응답 출력</strong>을 구현할 수 있었습니다.</p>\n<hr>\n<h1>Buffer 적용으로 대화 출력 성능 개선</h1>\n<p>일반적으로 LLM 애플리케이션 사용 시, 대화가 출력되는 동안 브라우저의 다른 탭을 활성 후 다시 LLM 애플리케이션과 대화 중이던 탭으로 돌아왔을 때 당연히 대화 출력이 완료되어 있을 거라 생각하실 겁니다.\n그런데 Chat DIC 프런트엔드 개발을 한참 진행하던 도중 “다른 탭을 보고 돌아왔는데도 여전히 답변이 출력 중인” 현상을 발견했습니다.</p>\n<p>이는 브라우저가 활성 탭에 자원(CPU, Memory)을 더 많이 활용하기 위해 비활성 탭에 <strong>리소스 제한(Throttling)</strong> 을 걸기 때문이었습니다.\n즉, 탭이 비활성화되면 서버로부터 받은 LLM 스트리밍 응답을 브라우저에 렌더링하는 과정에서 지연이 발생하는 것입니다.</p>\n<p>이를 해결하기 위해 <strong>Buffer</strong>를 도입했습니다.</p>\n<h3>개선 방식</h3>\n<ol>\n<li>탭이 비활성화될 경우,<br>\n들어오는 스트리밍 데이터를 <strong>임시 Buffer에 저장</strong></li>\n<li>탭이 다시 활성화되면,<br>\nBuffer의 내용을 꺼내서 한꺼번에 출력 후 Buffer 초기화</li>\n</ol>\n<p>아래는 Buffer 적용 예시입니다(원리만 나타낸 것으로, 실제 소스코드와는 조금 다릅니다).</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">...</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ChatApp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">const</span> isActiveRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> bufferRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onSubmitMessage</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> readableStream <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetchSSEStream</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token keyword\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> chunks <span class=\"token keyword\">of</span> <span class=\"token function\">parseSSEStream</span><span class=\"token punctuation\">(</span>readableStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">const</span> chunk <span class=\"token keyword\">of</span> chunks <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isActiveRef <span class=\"token operator\">&amp;&amp;</span> isActiveRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">// 탭이 활성화 된 경우 바로 메시지 출력</span>\n                    <span class=\"token operator\">...</span>\n                    \n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">// 탭이 비활성화된 경우, 버퍼에 저장</span>\n                    bufferRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onVisibilityChange</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> isActiveRef <span class=\"token operator\">&amp;&amp;</span> isActiveRef<span class=\"token punctuation\">.</span>current <span class=\"token operator\">===</span> <span class=\"token string\">'visible'</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">processBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 페이지가 다시 활성화되었을 때, 버퍼에 쌓인 데이터를 처리</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 페이지 활성상태 변경 이벤트 리스너 등록/해제</span>\n        document<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'visibilitychange'</span><span class=\"token punctuation\">,</span> onVisibilityChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            document<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'visibilitychange'</span><span class=\"token punctuation\">,</span> onVisibilityChange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span> processBuffer <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>위와 같이 LLM 응답 출력에 Buffer를 적용한 결과, 사용자는 “지연 없이 자연스럽게 대화가 이어지는 경험”을 얻게 되었습니다.</p>\n<hr>\n<h1>가상 DOM(Virtual DOM)을 활용한 Windowing 기법 적용</h1>\n<p>Chat DIC의 성능 테스트를 하면서 또 다른 문제를 발견했습니다. 대화가 길어질수록 브라우저에 대화가 출력되는 속도가 느려지는 것이었습니다.</p>\n<p>원인은 대화가 길어질수록 브라우저 화면에 렌더링되는 <strong>DOM 노드 수가 증가</strong>해서였습니다. 쉽게 말해 화면에 그려야 하는 요소가 계속 늘어나서 브라우저가 느려지는 것이었습니다.</p>\n<p>이를 해결하기 위해 가상 DOM(Virtual DOM)을 활용하는 <strong>Windowing</strong>이라는 기법을 적용했습니다.</p>\n<h3>Windowing의 원리</h3>\n<ul>\n<li>화면에 보이는 UI 요소만 실제로 렌더링</li>\n<li>보여줄 필요 없는 요소는 브라우저에 출력중인 DOM 노드에서 제거</li>\n<li>스크롤 위치에 따라 동적으로 렌더링 범위 조정</li>\n</ul>\n<h3>구현</h3>\n<p>Chat DIC 프런트엔드에서는 <a href=\"https://react-window.vercel.app/\">react-window</a> 라이브러리를 활용하여 간단하게 Windowing을 적용했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> List<span class=\"token punctuation\">,</span> useDynamicRowHeight <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-window'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ChatMessages</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> messages <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> rowHeight <span class=\"token operator\">=</span> <span class=\"token function\">useDynamicRowHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// 동적 행 높이 Hook 사용 (채팅 대화 내용 길이에 따라 행 높이 조절)</span>\n        <span class=\"token literal-property property\">defaultRowHeight</span><span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">RowComponent</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> index<span class=\"token punctuation\">,</span> style <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>style<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ChatMessage</span></span> <span class=\"token attr-name\">message</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>messages<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>w-full h-[calc(100vh-230px)] py-5 px-3<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span></span>\n                <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>chatdic-chat-list<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\">rowComponent</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>RowComponent<span class=\"token punctuation\">}</span></span>\n                <span class=\"token attr-name\">rowCount</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>messages<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">}</span></span>\n                <span class=\"token attr-name\">rowHeight</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>rowHeight<span class=\"token punctuation\">}</span></span>\n                <span class=\"token attr-name\">rowProps</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> messages <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span>\n            <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>효과</h3>\n<ul>\n<li>DOM 노드 수 일정하게 유지</li>\n<li>브라우저 자원 사용량 대폭 감소</li>\n<li>스크롤 및 렌더링 속도 향상</li>\n</ul>\n<p>아래 영상에서 <code class=\"language-text\">id=\"chatdic-chat-list\"</code>인 div 요소 아래의 노드 수가 어느 정도 증가하다가 일정 수준의 개수로 유지되는 것을 확인할 수 있습니다.<br/>\n대화가 늘어날수록 <code class=\"language-text\">data-react-window-index=\"??\"</code> 속성에 나타나는 숫자값의 변화를 보면 0으로 시작하던 index부터 점점 사라지며, 노드 수가 더이상 늘어나지 않습니다.</p>\n<p><img src=\"/16942c2b5804e388628fbef9bb4f2ad4/Windowing.gif\" alt=\"Windowing.gif\"></p>\n<p>따라서 도입 결과 대화가 길어져도 <strong>쾌적한 브라우저 성능</strong>을 유지할 수 있게 되었습니다.</p>\n<hr>\n<h1>맺음말</h1>\n<p>Chat DIC 프런트엔드 화면을 보면 언뜻 보면 단순한 채팅창 그 이상도 이하도 아닌 것처럼 느껴질 것입니다. <br/>\n그러나 그 뒤에는 여러 가지 최적화를 위해 고민했던 흔적들이 녹아 있습니다. <br/>\n추가적인 고민들은 Chat DIC를 고도화시키면서 지속해 나갈 예정입니다.</p>\n<p>그리고 Chat DIC 프런트엔드 개발 과정은 단순히 LLM을 “보여주는” 인터페이스가 아니라,<br>\n<strong>스트리밍, 성능 최적화</strong> 전체를 통합적으로 설계 및 적용할 수 있었던 경험이었습니다.</p>\n<ul>\n<li><strong>SSE로 실시간 스트리밍을 단순하게</strong>,</li>\n<li><strong>Buffer 및 Windowing 기법 사용으로 성능을 최적화</strong>하며,<br>\nChat DIC르 보다 사용자 친화적으로 발전시켜 나갈 수 있었습니다.</li>\n</ul>\n<blockquote>\n<p>Chat DIC는 단순한 채팅창이 아니라,<br>\n“대규모 언어 모델과 사용자 사이의 대화 경험을 효율적으로 전달하는 인터페이스 제공”을 목표로 합니다.</p>\n</blockquote>\n<p>앞으로도 SK플래닛 Data Infrastructure팀은 LLM 서비스의 <strong>실시간성, 확장성, 사용성</strong>을 높이기 위한 프런트엔드 기술을 지속적으로 검토 및 적용시켜 나갈 예정입니다.</p>\n<hr>\n<h1>참고자료</h1>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Server-sent_events/Using_server-sent_events\">Using server-sent events - MDN Web Docs</a></li>\n<li><a href=\"https://bunny.net/academy/http/what-is-sse-server-sent-events-and-how-do-they-work/\">What is SSE (Server-Sent Events) and How Do They Work?</a></li>\n<li><a href=\"https://legacy.reactjs.org/docs/faq-internals.html\">Virtual DOM and Internals - React</a></li>\n<li><a href=\"https://legacy.reactjs.org/docs/optimizing-performance.html#virtualize-long-lists\">Virtualize Long Lists - React</a></li>\n</ul>","frontmatter":{"title":"Chat DIC - 대화형 LLM 서비스의 프런트엔드 성능 개선기","date":"November 01, 2025","description":"SSE 스트리밍, 버퍼링, 가상화 — Chat DIC(챗디) 프런트엔드 개발에 적용된 주요 기술과 개선 사례를 공유합니다.","author":"songhy"}},"previous":{"fields":{"slug":"/skaisummit-skp25/"},"frontmatter":{"title":"미리 봅시다!@SK AI SUMMIT 2025 (+ 현장등록 방법, '숨은맛집' 세션소개 포함)"}},"next":null},"pageContext":{"id":"c9362c21-0ba0-5b2d-9929-5ea1e377c5bf","previousPostId":"2d1c95ec-56d0-567b-9a0c-9844a0826957","nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}