{"componentChunkName":"component---src-templates-blog-post-js","path":"/syrup-refactoring/","result":{"data":{"site":{"siteMetadata":{"title":"SK플래닛 TECH TOPIC"}},"markdownRemark":{"id":"709f10b8-c22f-50c2-98d0-b101f3ab257a","excerpt":"들어가며 Syrup은 재미있게 포인트 모으기, 모은 포인트 투자, 쿠폰 활용, 할인 혜택, 멤버십과 자산 내역 등을 한 곳에서 관리하는 SK플래닛의 대표 서비스입니다. SK플래닛은 고객에게 더 좋은 경험을 제공하기 위해서 응답 속도 위주로 Syrup 서비스를 개선했습니다. 본 내용은 Syrup…","html":"<h3>들어가며</h3>\n<p>Syrup은 재미있게 포인트 모으기, 모은 포인트 투자, 쿠폰 활용, 할인 혜택, 멤버십과 자산 내역 등을 한 곳에서 관리하는 SK플래닛의 대표 서비스입니다.<br>\nSK플래닛은 고객에게 더 좋은 경험을 제공하기 위해서 응답 속도 위주로 Syrup 서비스를 개선했습니다.<br>\n본 내용은 Syrup 서비스 개선에 적용한 기술, 해당 기술을 채택한 이유, 개선 과정에서 경험한 시행 착오 그리고 개선 결과입니다.</p>\n<h3>개선 배경</h3>\n<p>Syrup 서비스는 2010년에 처음 출시되어 13년 이상, SK플래닛 고객이 사용하고 있습니다(2023년 기준).<br>\n이렇게 오랜 기간 Syrup 서비스를 제공하면서 API 서버의 레거시화가 진행되었는데, 특히 모바일 웹이 호출하는 웹 게이트웨이 서버의 응답 속도가 문제였습니다.<br>\n이러한 웹 게이트웨이의 느린 응답은 전체 Syrup 모바일 웹의 로딩과 렌더링 속도에 직접적인 영향을 주었고, Syrup 모바일 웹의 응답 속도와 서비스 개선을 위하여 신규 서버 구축의 필요성이 대두되었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/63cf0f3963c5d4f942332c052fb590d7/7c1cd/syrup-01.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.39240506329114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACHklEQVR42n1Ty27TQBTNv1ZixyeAxI4vACQWqPwAGwQbUKkQC5AgShrR0jY0fiR+xfZ4PGOP7UwO906SwoJ2pKNj+dpH5557Z/Tr/AKz6RkmP8aYTaaYjMeoKgk+2+0W/zulqBDFMZbLJdI0xTrPUSvlaiM/XqHsGojBOA7WCXTT3CnY9z0830dOIkmaoChLFEUBdRCUx6foH7zCcPQC9ugZzMPn6NLCFS0JsiTD7gVVXSNOEiRZhpAcBmGIdL2GpPc7wTdfoB+/hnlyDPPoJdRT4rzc/b21f4GdW27zZrFwbS6I2a2oKsiDQ60q6F5hsBv6r0XbdxioLW163BQNQtk5eMIgSHMEJMBtxpRdTpxTuym5vXWYJVRIMwzdBkJbNMpA0kc/vQgffku8m0V4Ow1x4mm8/3qG0FtgRQNhd3EUwfc8JBQBD4UzH1Vk124s2rbG/OYSom7R1BLzOMepp3AyL/DxKsfn0ODT5ApRGEBIiYhEODtGQqgODuv9Q98ZiCKF1hotTbkbLCKhkZLjrDaIZYtSaqwoQ58GEZE7j9wxs8PbDCM/xMW378jcpBSUbtAac+faCCFcbiUxgwfCrMiIE4yDJRazcydWVTVqYrMX/HdtDtJcu7y+xopc+bw2e3CuHQ1zVBQl2q4Dt17ul7Rt23tvSkYrwwINfcfOeKl5ynyDRpzZASzExWEYcN8ZNhu32NZaB749bumbBn8AAFWOPB/9C8QAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-01\"\n        title=\"\"\n        src=\"/static/63cf0f3963c5d4f942332c052fb590d7/7c1cd/syrup-01.png\"\n        srcset=\"/static/63cf0f3963c5d4f942332c052fb590d7/c26ae/syrup-01.png 158w,\n/static/63cf0f3963c5d4f942332c052fb590d7/6bdcf/syrup-01.png 315w,\n/static/63cf0f3963c5d4f942332c052fb590d7/7c1cd/syrup-01.png 582w\"\n        sizes=\"(max-width: 582px) 100vw, 582px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>현상 및 개선 목표</h3>\n<p>Syrup은 멤버십 카드/쿠폰, 불리기(금, 조각, 주식, 가상화폐, 부동산), 마이데이터 등의 서비스를 제공하기 위하여 많은 외부 파트너와 제휴하고 있습니다.</p>\n<p>지금까지 Syrup 웹 게이트웨이는 파트너가 제공하는 정보를 조회하기 위하여 다수의 API를 호출하는데, 다음의 방법으로 API를 호출했습니다.</p>\n<p>첫 번째는 웹 게이트웨이가 순차적으로 API를 호출하여 모든 응답이 완료될 때까지 대기한 후, 최종으로 데이터를 병합하여 클라이언트(프론트엔드)로 보내는 방법입니다.<br>\n이처럼 다수의 API를 순차적으로 처리할 때, 응답 시간이 지연되는 문제가 있습니다.</p>\n<p>예를 들어, 다음 그림에서 Gateway의 getSummary API 응답 시간은 Gateway 내부에서 호출하는 API인 getToken, getMember, getFinanceInfo, getCardInfo, getCouponInfo, getProfitInfo 의 응답 시간을 합한 것입니다.<br>\n이러한 결과로 전체 API 응답 시간은 402.063 ms가 되어 클라이언트가 getSummary API를 호출한 후, 대기 시간이 길어지는 문제가 있었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/95510340db6f39e9eedfe4dc70a4a685/e80ec/syrup-02.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.316455696202528%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVR42l2Q/VKCUBDFecTepZ6mf32A/ipGg4RqypocP1JAQ0FFAfkIsMYwLqflqs3UnfnNzs7sOXvuCgtnjXanB99d4Mma4rz1AnViobVY4pG4mztQpjbE3iuuCLE/4L1qz6Bae27tOWTS2PE7hCAMITZuIEkKumMTz1ML95oOicT6ykUQRdjmOY6vLEswxlAUBa//EVZBilrdQE3U4QYZF3nZBrMoxsjzIXb7kDUDA0pkOkvkux25sj8LOJUhVSEJJ+gqZ+g0T5GEJgpWDe0F1cCWDL6INn2tScYPxggypX+j9Fma4vuQ9JhYWMcaLtQTjh8PuVHBCm5Wbf5NcqhukmLs0d3ptpdkXKebXg91NPQRgo9P/ACNEW76h+u3HQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-02\"\n        title=\"\"\n        src=\"/static/95510340db6f39e9eedfe4dc70a4a685/f058b/syrup-02.png\"\n        srcset=\"/static/95510340db6f39e9eedfe4dc70a4a685/c26ae/syrup-02.png 158w,\n/static/95510340db6f39e9eedfe4dc70a4a685/6bdcf/syrup-02.png 315w,\n/static/95510340db6f39e9eedfe4dc70a4a685/f058b/syrup-02.png 630w,\n/static/95510340db6f39e9eedfe4dc70a4a685/40601/syrup-02.png 945w,\n/static/95510340db6f39e9eedfe4dc70a4a685/78612/syrup-02.png 1260w,\n/static/95510340db6f39e9eedfe4dc70a4a685/e80ec/syrup-02.png 2582w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이때 응답 시간을 줄이기 위한 방법으로 서로 의존성이 없는 API를 비동기로 호출하기도 했습니다.<br>\n이 방법은 getSummary API의 응답 시간은 단축되지만, 가장 많은 시간이 소요되는 API에 의존하게 됩니다(다음 그림에서 ProfitService의 getProfitInfo API 응답 시간에 의존).<br>\n특히 특정 API가 타임아웃 시간까지 대기하면, 전체 응답 시간은 타임아웃 시간까지 지연됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/575745dfd2f54b7e9ddee43934eedce4/36405/syrup-03.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.58227848101266%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABJklEQVR42m2P207CQBBA+Th/wF/xA3zkE3j2CXkjKMEGBBSQOzGUcqncLBSqBChIDDV0e1yq+OQkJzO7M3uyE5hbS1qaynw2pD03CD1Vuev1qU9n1GcWVUlZ1g/6C9meTrrTIz96pSjvihPzj4IxRbXeCKzWNgklS+wmSVMfoE4mNEZjbis1mnJovV7h7PfgeXhC4Ies/+PYDyzWOyKZAVeJLgPT9uc/9g6mvaH/vuC6XCUi5eFSBaXT9d8KTyDED95R9MvxHNjaJmr+klrqgqXV4CA/IdyDL945DqFcgWAsTjCukFA1Pne7P9FJesJ1XbnyZkSicE40c4ZhpX2REK6fvw4uUa1L+Fkl0tRQ9D7Jlkaq3eVekhuOKU1NSpMpj2MDc7PlG4H3anmKzTq8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-03\"\n        title=\"\"\n        src=\"/static/575745dfd2f54b7e9ddee43934eedce4/f058b/syrup-03.png\"\n        srcset=\"/static/575745dfd2f54b7e9ddee43934eedce4/c26ae/syrup-03.png 158w,\n/static/575745dfd2f54b7e9ddee43934eedce4/6bdcf/syrup-03.png 315w,\n/static/575745dfd2f54b7e9ddee43934eedce4/f058b/syrup-03.png 630w,\n/static/575745dfd2f54b7e9ddee43934eedce4/40601/syrup-03.png 945w,\n/static/575745dfd2f54b7e9ddee43934eedce4/78612/syrup-03.png 1260w,\n/static/575745dfd2f54b7e9ddee43934eedce4/36405/syrup-03.png 2486w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>또한 스프링 MVC(Model, View, Controller)를 사용할 경우, 비동기 호출을 위해 일반적으로  CompletableFuture를 사용하는데, CompletableFuture는 다음과 같은 문제가 있습니다.</p>\n<ul>\n<li><strong>복잡성</strong></li>\n</ul>\n<p>CompletableFuture를 사용하면 코드가 복잡해질 수 있습니다. 특히 여러 개의 thenCombine을 조합하여 연결할 때, 다음 코드와 같이 콜백 함수와 데이터 병합 코드로 인해 가독성이 떨어질 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static void main(String[] args) {\r\n    CompletableFuture&lt;String> SK = CompletableFuture.supplyAsync(() ->\r\n        \"SK\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Planet = CompletableFuture.supplyAsync(() ->\r\n        \"Planet\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Syrup = CompletableFuture.supplyAsync(() ->\r\n        \"Syrup\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Development = CompletableFuture.supplyAsync(() ->\r\n        \"Development\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> Team = CompletableFuture.supplyAsync(() ->\r\n        \"Team\"\r\n    );\r\n\r\n    CompletableFuture&lt;String> future = SK\r\n        .thenCombine(Planet, (result, planet) -> result + \" \" + planet)\r\n        .thenCombine(Syrup, (result, syrup) -> result + \" \" + syrup)\r\n        .thenCombine(Development, (result, development) -> result + \" \" + development)\r\n        .thenCombine(Team, (result, team) -> result + \" \" + team);\r\n\r\n    try {\r\n        System.out.println(future.get());\r\n    } catch (InterruptedException | ExecutionException e) {}\r\n}</code></pre></div>\n<ul>\n<li><strong>스레드 풀 관리</strong></li>\n</ul>\n<p>CompletableFuture는 백그라운드 스레드 풀을 사용하여 비동기 작업을 하기 때문에 스레드 풀을 관리해야 합니다. 스레드 풀을 관리하지 않으면 스레드가 과도하게 생성되거나 리소스 누수 문제가 발생될 수 있습니다.<br>\n실제 CompletableFuture 사용 시, 별도로 스레드 풀을 관리하지 않아서 장애가 발생된 경험이 있습니다.</p>\n<ul>\n<li><strong>콘텍스트 스위칭 비용</strong></li>\n</ul>\n<p>비동기 API 호출을 위해 작업이 다른 스레드로 전환될 때, 추가 시간과 메모리 사용 등 오버헤드 비용이 발생하여 전체적인 서버 성능에 영향을 미칠 수 있습니다.</p>\n<p>두 번째는 클라이언트에서 다수의 API를 병렬 호출하여 전체 응답을 화면에서 처리하는 방법입니다.<br>\n특히 React, Vue와 같은 모던 프론트엔드 개발 환경은 전체 페이지 단위가 아닌 컴포넌트 단위로 API를 호출하는 사례가 많아지면서 이와 같은 병렬 호출 방법이 주로 사용됩니다.</p>\n<p>다수의 API를 호출할 때에도 다음 그림과 같이 AuthService, MemberService에서 제공하는 API(인증/인가 등)가 중복 호출되는 문제가 발생되어 AuthService, MemberService의 트래픽을 증가시키고 있었습니다. 또한 Gateway API 호출 건수가 많아짐에 따라 고객의 네트워크 비용도 증가 됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d3813c9a5de3d8c9e119005b1ffcd9e8/e996b/syrup-04.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.79746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACjUlEQVR42i2Sy27aQBSGeZc+QDd9rSy7atfdZp9uKkWp1EWjqllUSaTmSkIChIRwx8EYDLbBNmAMvsLXY9SRRnPG8jnz33Jt9Y2GqlBT2ry+dXgbaGRrYs95bSjomk6h3uC4XOGq0STfanNeKnP6Wue01uCy1+e6P+BC1SiNxuS81oC4NiRt6gSlDmHfYLPdYhoWV5d5KoUSeWk87SjcyS7IAMsw8T2PMIqJk5Q4TYmSROqE3HrvG/6HTwTvPxK+2yP+fLRD2NLq7B9/4eD3Pq5t7L6p1oSmPhYmPR76GmVtSKGr8NhTeRYAqjsjF780WFw/Ed2/4J3fEilD2GzwQx/N7mI4PXzfw083rASBH8do+oiuadKRrUymu0G92QzL98ktFi6zxWyHYLvdyKyUJIqYTB2arSbmQOWsWuXg8YkrpcedUL6tvgr9LnfKG8WBzrNpURwZKI5Lbum6RKs1tu2gjhw2Qcw2TehrIw6/n3Dy65ym0GpbFjdizp+XKh1VdJT7Ok5YyeN+EAijiEjuuXC93qGbTzWciU64CkijEHe25CZf5bFQYz33dv9kTV4YMsgQiasZynsx6l7OB3FaXyzF5amNLXbP3DmrpU8iDanotPACTGvJwvFRxgbFsUlLWDREimK7w4MYcy+7JHpWxPWSUO5lpgxbXZrFCs58jicDsxhsxBTTMMjf/aVZfeSs8sRh+ZmLWp3yYIja76OLGWPpmforbGFpSe9MzlwQBkSiw0p0nItTWZ0tpW/y9ccNRz9vsc0poeiaF2QloVYVinVB1hDkNV2nJejbE5uJJ5STLJBxvAtlVqeCLlsroa45DiPXIZQQpxKJVO7ZOfwfla5o2ZVs9jJD5wucdcA/4ZMjuAITTFgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-04\"\n        title=\"\"\n        src=\"/static/d3813c9a5de3d8c9e119005b1ffcd9e8/f058b/syrup-04.png\"\n        srcset=\"/static/d3813c9a5de3d8c9e119005b1ffcd9e8/c26ae/syrup-04.png 158w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/6bdcf/syrup-04.png 315w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/f058b/syrup-04.png 630w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/40601/syrup-04.png 945w,\n/static/d3813c9a5de3d8c9e119005b1ffcd9e8/e996b/syrup-04.png 1050w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이러한 문제를 해결하기 위해 신규로 구축되는 Syrup 웹 게이트웨이에는 WebFlux, Server Sent Events를 적용하여 신규 서버를 구축했고, 추가로 모던 프론트엔드 개발 환경을 통한 렌더링 성능 향상 및 사용자 경험 개선을 위해 프론트엔드 환경도 Next.js를 적용했습니다.</p>\n<h3>적용 기술</h3>\n<h4>1. WebFlux</h4>\n<p>WebFlux(<a href=\"https://docs.spring.io/spring-framework/reference/web/webflux.html\">https://docs.spring.io/spring-framework/reference/web/webflux.html</a> )는 스프링(Spring) 5부터 도입된 리엑티브 프로그래밍을 위한 모듈 중 하나입니다.<br>\n리엑티브 프로그래밍은 비동기 동작이고 이벤트 기반의 애플리케이션을 개발하기 위한 패러다임이며, 특히 대규모의 동시성이 필요한 애플리케이션에 적합합니다.</p>\n<p>WebFlux는 다음과 같은 특징이 있습니다.</p>\n<p><strong>비동기 및 논블로킹</strong><br>\n비동기 방식으로 HTTP 요청을 처리하여, 블로킹 I/O 작업이 최소화됩니다. 이를 통해 대규모의 동시 요청을 처리하고 높은 확장성을 제공합니다.</p>\n<p><strong>리액티브 스트림</strong><br>\n리액티브 스트림 API를 사용하여 데이터를 처리합니다. 이 기능은 데이터를 스트림으로 처리하여 실시간 데이터를 처리할 수 있습니다.</p>\n<p><strong>함수형 프로그래밍</strong><br>\n함수형 프로그래밍 패러다임을 따르며, 람다 표현식 및 스트림 처리와 같은 기능을 활용하여 코드를 작성할 수 있습니다.</p>\n<p><strong>다양한 백엔드 런타임</strong><br>\nNetty와 Servlet 3.1+와 같은 다양한 런타임을 지원하고, 선택한 런타임에 맞게 웹 애플리케이션을 개발할 수 있습니다.</p>\n<p>따라서 WebFlux를 사용하면 대규모의 실시간 애플리케이션을 구축할 때 높은 성능 보장과 확장성을 달성할 수 있고, 비동기 및 이벤트 기반 프로그래밍 모델을 활용할 수 있습니다.</p>\n<p>WebFlux는 다음과 같은 장단점이 있으며, Syrup 웹 게이트웨이는 RDBMS와 직접 연동하지 않고, 다른 파트너 사와 연동이 많은 서버임을 고려하여 WebFlux가 적합하다고 판단했습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e10982dcf72a8c05ec297198c75baa25/99072/syrup-05.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.72151898734178%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACCElEQVR42o1UTZOaQBDl//+dHHLINeaw1ubgqiCgosLA8A0Kfvsyr2sxW6lUslPVxTD0vH7d/RrL930sl0t4ngfHcTAajbBer7HZbMS22y0Wi4V8p+9qtZKz8Xgs97in8c5ut4NFZwJNp1NxzvMc+/0eTdOgKArZHw4H2LaN2WyGIAiQpqlYXdeoqurp1/c9LLKgM0G11ijLElmWIYoihGEoAbquEyAGdF0X8/lc2BCIvgS/3W44Ho9k6Ehk23YMiJI0J5OJpPT2NhVgsiAAUyQwUycICRBQKYXr9YrT6QSLL2TSNLUckKFSMeI4xvl8xuVyEUAa2Q6seP7nEoZaKxN1izjRxhIpcJpG5rmGMmcMSHAyJzt+556MGZxM27b9Dei6X5DErxjNQ2zjFCoK4XtfsQ5e8O3nUkDLssDj8cD9fhcb9qzbcPYELEsfOnnB95lpfZQg3Bm28QjB5hU/vBSJYVAUOT6z3gHZ+gZpUaKqzTPVplYhsjyB0qZmJq3a1O/TgCywaCnPnvVgBiar52JzhrT+C8jissiUwqB2rRMj2kq6Ttt3vThzz+dgFPLHd+rV+lfEvjdOlJPeoGsbef/bYpMe7ylZHCtqKzGSoYhp3FMuPK+MdYVGZTrdNK1I6KMNZeLosesCSGPanBiOFo1jxjToyBryEsXMknBUh38AdSllMX6clF8F0B/Vagor2AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-05\"\n        title=\"\"\n        src=\"/static/e10982dcf72a8c05ec297198c75baa25/f058b/syrup-05.png\"\n        srcset=\"/static/e10982dcf72a8c05ec297198c75baa25/c26ae/syrup-05.png 158w,\n/static/e10982dcf72a8c05ec297198c75baa25/6bdcf/syrup-05.png 315w,\n/static/e10982dcf72a8c05ec297198c75baa25/f058b/syrup-05.png 630w,\n/static/e10982dcf72a8c05ec297198c75baa25/99072/syrup-05.png 842w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>추가로 WebFlux 적용할 때, 성능 향상 이외에 다음과 같은 장점이 있었습니다.</p>\n<p><strong>(1) CompletableFuture를 사용하는 대신, Reactor의 Mono.zip을 활용하면 단순한 비동기 처리가 가능합니다.</strong>\r\nCompletableFuture를 사용하는 경우, thenCombine마다 콜백 함수가 필요하고 콜백 함수에서 이전까지 결과와 현재 결과를 병합하는 코드가 필요해 전체 코드가 복잡해집니다. 반면 Mono.zip을 사용하면 하나의 콜백 함수에서 모든 처리가 가능합니다.</p>\n<p>다음 코드에서 주석 부분은 CompletableFuture를 사용할 때 코드이고, 주석 제거 부분은 WebFlux 사용시 코드입니다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static void main(String[] args) {\r\n//    CompletableFuture&lt;String> SK = CompletableFuture.supplyAsync(() ->\r\n//        \"SK\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Planet = CompletableFuture.supplyAsync(() ->\r\n//        \"Planet\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Syrup = CompletableFuture.supplyAsync(() ->\r\n//        \"Syrup\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Development = CompletableFuture.supplyAsync(() ->\r\n//        \"Development\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> Team = CompletableFuture.supplyAsync(() ->\r\n//        \"Team\"\r\n//    );\r\n//\r\n//    CompletableFuture&lt;String> future = SK\r\n//            .thenCombine(Planet, (result, planet) -> result + \" \" + planet)\r\n//            .thenCombine(Syrup, (result, syrup) -> result + \" \" + syrup)\r\n//            .thenCombine(Development, (result, development) -> result + \" \" + development)\r\n//            .thenCombine(Team, (result, team) -> result + \" \" + team);\r\n//\r\n//    try {\r\n//        System.out.println(future.get());\r\n//    } catch (InterruptedException | ExecutionException e) {}\r\n\r\nMono&lt;String> SK = Mono.just(\"SK\");\r\nMono&lt;String> Planet = Mono.just(\"Planet\")\r\nMono&lt;String> Syrup = Mono.just(\"Syrup\");\r\nMono&lt;String> Development = Mono.just(\"Development\");\r\nMono&lt;String> Team = Mono.just(\"Team\");\r\n\r\nMono.zip(SK, Planet, Syrup, Development, Team).map(t ->\r\n    t.getT1() + \" \" + t.getT2() + \" \" + t.getT3() + \" \" + t.getT4() + ' ' + t.getT5()\r\n).subscribe(System.out::println);\r\n}</code></pre></div>\n<p><strong>(2) 타임아웃 제한 없이 롱-폴링을 사용할 수 있었습니다.</strong><br>\n기존의 Syrup은 마이데이터 자산 업데이트 체크를 위해 폴링 방식을 사용했습니다. 폴링을 사용하면 프론트엔드에서 매번 업데이트 체크 요청을 전송해야 하므로 고객 네트워크 비용이 증가됩니다.<br>\n이를 개선하기 위해 업데이트 체크 역할을 Gateway로 이전하여 롱-폴링 사용을 고려했으나, 업데이트가 진행되는 기간에 Gateway 서버의 스레드 점유 때문에 서버 비용이 증가되는 문제가 있었습니다. 따라서 롱-폴링을 사용하면, 타임아웃 설정이 필수입니다.<br>\n이번에 WebFlux로 서버를 개편하면서 연결 요청마다 스레드가 생성되지 않는 것을 이용하여 롱-폴링 시 별도의 타임아웃 설정 없이 사용할 수 있었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/832ffa8b102d434ee56cfc36358b464d/cf0be/syrup-06.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.0253164556962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVR42oWT6a6CMBCFef8XhD+orLK4sKkgwphvkmmIyeU2GVvbM2fO6RSvLEtJkkTu97tcr1cJgkDO57M8n085HA4Sx7HM8yzLskhRFIrtuk7I831fc/q+lzAMJU1T8QAOw6Dguq6VGBKiaRpZ11VsQExynudyuVwUezqdJMsyLQKX9/l8pG1beTwe8nq95Ha7aQH+s/9LOE2TrtmnoGEppIT8YI8NO4SYROYt4fv91jBCzsdx1D3wjhC5yOZesMI9EdzPX4QMHJhl1DrLKMOO2aea3dceIUJsD2dOIdIJrFtAyrxHaHlgse4IUbW1TIejKNIu/mf5eDxqLmtnGWsGxgZ2IeIqfru8bYp11hrrFOLf1FGJN0lAvqeQPN4k75fijpAO8f4gwyZr5l/LKARbVZUGa8O5h00CVZnt8+IajGA7DEsTILDP0rCcfwEwiaD5vrq+6QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-06\"\n        title=\"\"\n        src=\"/static/832ffa8b102d434ee56cfc36358b464d/f058b/syrup-06.png\"\n        srcset=\"/static/832ffa8b102d434ee56cfc36358b464d/c26ae/syrup-06.png 158w,\n/static/832ffa8b102d434ee56cfc36358b464d/6bdcf/syrup-06.png 315w,\n/static/832ffa8b102d434ee56cfc36358b464d/f058b/syrup-06.png 630w,\n/static/832ffa8b102d434ee56cfc36358b464d/40601/syrup-06.png 945w,\n/static/832ffa8b102d434ee56cfc36358b464d/78612/syrup-06.png 1260w,\n/static/832ffa8b102d434ee56cfc36358b464d/cf0be/syrup-06.png 1994w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>2. Server Sent Events</h4>\n<p>Server Sent Events(<a href=\"https://docs.nestjs.com/techniques/server-sent-events\">https://docs.nestjs.com/techniques/server-sent-events</a>, SSE)는 서버에서 클라이언트로 단방향 데이터를 전송하기 위한 웹 기술입니다. SSE는 서버에서 클라이언트로 데이터를 푸시하고, 웹 페이지가 열려 있는 동안 데이터를 실시간으로 업데이트할 때 사용됩니다.<br>\n따라서 SSE는 실시간으로 정보가 업데이트 되는 스트리밍 뉴스, 실시간 주가, 온라인 게임, 알림 및 기타 웹 애플리케이션에 유용하게 사용됩니다.</p>\n<p>이러한 SSE의 주요 특징은 다음과 같습니다.</p>\n<p><strong>단방향 통신</strong><br>\n서버에서 클라이언트로 단방향 통신을 제공합니다. 이것은 클라이언트가 주기적으로 서버에 데이터를 요청하지 않고도 서버가 데이터를 보낼 수 있습니다.</p>\n<p><strong>간단한 프로토콜</strong><br>\nSSE는 간단한 프로토콜로써, 웹 브라우저에 내장된 EventSource 객체를 활용하여 쉽게 사용할 수 있습니다.</p>\n<p><strong>Event-Driven 구조</strong><br>\n서버는 이벤트 스트림으로 클라이언트에 이벤트를 보낼 수 있으며, 클라이언트는 JavaScript 이벤트 핸들러를 사용하여 처리합니다.</p>\n<p>SSE를 구현하려면, 서버 측은 특정 HTTP 헤더('Content-Type: text/event-stream')를 사용하여 SSE 스트림을 전송하고, 클라이언트 측은 EventSource API를 사용하여 이벤트를 수신하는 코드를 작성하면 됩니다.</p>\n<p>Syrup은 다음 그림과 같이 SSE를 적용하여 비동기로 호출되는 API 전체 응답을 기다리는 것이 아닌, 개별 API응답을 즉시 프론트엔드에 푸시하고, 프론트엔드에서는 바로 렌더링하여 사용자 경험을 개선했습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1244bef0f52a47d6af9fb577b4ea5cf6/85053/syrup-07.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.12658227848101%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACSUlEQVR42n2SzXISQRSF5w3d+CqufIGs3Ll14cIstCqlhmAkSSlJRZMQEJSABBiYAZppZgDn/6dnjrebhEqp5VR9dW/3dJ8+93ZrhmGhdt3A1NRxOezjefUch90ezkcGTonP+hgVGpcaTewTB60fOBmMcNLXtxzf6jgbjpFkGTSLc5Q+VFAuV1DrdHHRH+LspovS1TUGbA7fdZHnOeQnKCqE+Bual+s0xld4efAdL941MJo5aiN3PYydJWrkcPf8K15/uaR4gUqnp1wURYGcKP5ACS5tA/VPT3F19ASctZHl0olQwp25hZ3SIXbe7uPZ4REuercQaboRkI7I2RYay3mNL/vYqz7Gm5NHmFg1oAAykSnByWqNV/UWdutN7LW7KH9r4X2tjnKzhY/tDqpUQZV6fDzQcUOHy81akmb4OTQxZgtyVyBJEqTkQiLzmEgojyj6YYSY8pjKTshVSq5kVGRi4zCOInQ7HYx0HUkcw/d9RRAECBU+wjCA73nwqLe5bMddycVdmRJ5MUrQmDIw7sBZe2DWCvp4BnO6gDGx0DN+oa27GE9sTJlNc5z+cRpbWKwCrN1we8v3L0GzHQeM6reXa/ixwMqNMJ078MIUQ9MGc0KYM5sO9BGlBZWeb6A8TjcOH37avbJ8BoLSMEqgj0xEcUpuGFZrF7M5p0MXtAaqz4KQMRP/E1SLAC+I0e0NEZDgYDQBd9aYzCwqmUMowQf8S1DWD9XUnG5UwPVC6qMJP4ioZ0y1YsoscsjptgWtybbIF6Le2QPB363ihg1WnubuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-07\"\n        title=\"\"\n        src=\"/static/1244bef0f52a47d6af9fb577b4ea5cf6/f058b/syrup-07.png\"\n        srcset=\"/static/1244bef0f52a47d6af9fb577b4ea5cf6/c26ae/syrup-07.png 158w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/6bdcf/syrup-07.png 315w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/f058b/syrup-07.png 630w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/40601/syrup-07.png 945w,\n/static/1244bef0f52a47d6af9fb577b4ea5cf6/85053/syrup-07.png 1225w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4>3. Next.js</h4>\n<p>Next.js(<a href=\"https://nextjs.org\">https://nextjs.org</a> )는 React 기반의 웹 애플리케이션 프레임워크로써 웹 애플리케이션을 쉽고 빠르게 개발하도록 도와주는 도구와 환경입니다. Next.js는 다음과 같은 주요 기능을 제공합니다.</p>\n<p><strong>서버 사이드 렌더링(Server Side Rendering, SSR)</strong><br>\nNext.js는 기본적으로 서버 사이드 랜더링을 지원하며, 이를 통해 초기 페이지를 로딩할 때 서버에서 페이지를 렌더링하여 검색 엔진 최적화(SEO)와 초기 로딩 속도를 높일 수 있습니다.</p>\n<p><strong>정적 사이트 생성(Static Site Generation, SSG)</strong><br>\nNext.js는 빌드 시 미리 정적 HTML 파일을 생성할 수 있습니다. 이것은 정적 HTML을 우선적으로 노출시켜 초기 로딩 속도 및 사용자 경험을 향상시키고 CDN(Content Delivery Network)을  통한 캐싱도 가능합니다.</p>\n<p><strong>데이터 미리 가져오기(Date Pre-fetching)</strong><br>\n페이지 이동 전에 필요한 데이터를 미리 가져오는 기능을 지원합니다. 이 기능으로 페이지는 빠르고 부드럽게 전환됩니다.</p>\n<p>Next.js는 다음과 같은 장단점이 있으며, Syrup은 Next.js 의 장점만을 수용하여 정적 사이트 생성(SSG)만 적용하기로 했습니다. 서버 사이드 렌더링을 적용하면 별도의 서버 리소스, 모니터링, 운영 인력 등이 필요하기 때문에 서버 사이드 렌더링은 효과 대비 비용 효율성이 떨어진다고 판단했습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9b9c8d200e51dd72e326e5f7d734572b/121b3/syrup-08.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.08860759493672%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABgklEQVR42pWS6W6DQAyEef+ni/ILUiAn95EEAgFyuPtZ3SiqkJquNFqLHY/HNs56vZZ3LBYL8TxPiqKQOI4lSRLZ7XYSBIHC9329l8ul8tI0VR7Y7/fikLBarZSoJNdVgcPhoKJVVcn1epUsy8Q1bxTdbDaK4/GogFfXtZRlKQ4JCEAkbi8XJRH3fS/P51Nut5ucz2fFMAxaYBxHvcHj8RAOscMDSXwkrkwLfdfJOE0yGXDu97u2HoahFubebrfaYhRFLwM4dUjCAYTSfGyAcZKaFmmDA6dpGk1o2/blGlBs+il+Md29HEKkncBUt4uguhUk+a9DvnM6ndQutpkZwsyCIuDfggixZX4F2mb9xHmeS2dmSRsQPxZkNnb9ACFcvm+R+GNB2rU/LQ4BM+TRtjwYQbZuPugS5sBfwsgcEnHAbWMemBt3VdXSZJE0eSyV2TqOcQvvN9ThnHUqksgMs7yQNPQkCVyN+77TNzhzZ1YQIVzQBkvxvnwFfwRjsO7nBL8BT4nmeQHHjhsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-08\"\n        title=\"\"\n        src=\"/static/9b9c8d200e51dd72e326e5f7d734572b/f058b/syrup-08.png\"\n        srcset=\"/static/9b9c8d200e51dd72e326e5f7d734572b/c26ae/syrup-08.png 158w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/6bdcf/syrup-08.png 315w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/f058b/syrup-08.png 630w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/40601/syrup-08.png 945w,\n/static/9b9c8d200e51dd72e326e5f7d734572b/121b3/syrup-08.png 1070w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3>개선 과정에서 시행착오(WebFlux 위주)</h3>\n<p>WebFlux를 적용하면서 겪었던 몇 가지 시행착오를 정리해 보았습니다.</p>\n<p>첫 번째는 리액티브 프로그래밍 모델에 대한 적응이 필요했습니다.<br>\n예를 들어 다음 코드에서 getSummaryBad 함수가 실행되어도 실제 System.out.println(res); 구문이 실행되지 않았는데 이유가 무엇일까요?</p>\n<p>이유는 (1)리엑티브 프로그래밍 모델은 발행자(Publisher)-구독자(Subscriber) 모델이 사용되는데 별도 구독을 하거나 하나의 구독 파이프라인 안에서 실행되고, (2)발행자의 발행 준비가 완료된 후, 푸시되어야 구독이 일어나기 때문입니다.</p>\n<p>Mono.just를 사용하면, 즉각적인 발행이 이루어지므로 발행은 별개로 하고, getSummaryBad는 별도의 구독도 없고 파이프라인에도 포함되지 않아 System.out.println(res); 구문이 실행되지 않았습니다. 그리고 getSummaryNormal은 구독 파이프라인에 포함되어 로그가 출력되는 차이가 있습니다.</p>\n<p>이와 같은 우리는 리엑티브 프로그래밍 모델에 대한 적응이 필요했으며, 리엑티브 시스템의 기본 개념, 리엑티브 프로그래밍 모델, 리엑터 라이브러리의 사용법 등을 익히는 데 6개월 이상 소요되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">private Mono&lt;String> getToken() {\r\n    return Mono.just(\"token\");\r\n}\r\n\r\nprivate Mono&lt;String> getMember() {\r\n    return Mono.just(\"member\");\r\n}\r\n\r\nprivate Mono&lt;String> getMembershipInfo() {\r\n    return Mono.just(\"membership\");\r\n}\r\n\r\n// reactive programming bad example\r\npublic Mono&lt;ServerResponse> getSummaryBad(ServerRequest request) {\r\nMono token = getToken();\r\nMono member = getMember();\r\n\r\ntoken.flatMap(res -> {\r\n    System.out.println(res);\r\n    return res;\r\n});\r\n\r\nmember.flatMap(res -> {\r\n    System.out.println(res);\r\n    return res;\r\n});\r\n\r\nMono membership = getMembershipInfo().flatMap(res -> {\r\n    return Mono.just(res);\r\n});\r\n\r\nreturn ServerResponse.ok().body(membership, String.class);\r\n}\r\n\r\n// reactive programming normal example\r\npublic Mono&lt;ServerResponse> getSummaryNormal(ServerRequest request) {\r\n    return token.flatMap(tokenRes -> {\r\n        System.out.println(tokenRes);\r\n        return member.flatMap(memberRes -> {\r\n            System.out.println(memberRes);\r\n            return getMembershipInfo().flatMap(membershipRes -> {\r\n                return ServerResponse.ok().body(Mono.just(membershipRes), String.class);\r\n            });\r\n        });\r\n    });\r\n}</code></pre></div>\n<p>두 번째는 멀티 스레드 기반 라이브러리를 사용할 수 없습니다.<br>\nWebFlux는 스프링 MVC와 다르게 연결 요청마다 별도의 스레드를 생성하지 않기 때문에 스레드 기반으로 데이터를 관리하는 라이브러리를 사용할 수 없습니다.  만약 이것을 무시하고 사용하면 다른 사용자의 정보가 노출되는 지옥이 펼쳐질 수 있습니다.</p>\n<p>대표적인 멀티 스레드 기반 라이브러리는 ThreadLocal, MDC(Mapped Diagnostic Context) 등이 있으며, 이를 대체하기 위해 WebFlux는 ContextView를 제공합니다. 또한 로그 추적을 위해서 Spring Cloud Sleuth를 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// context write\r\n.contextWrite(context -> {\r\n    context = context.put(ContextType.MEMBER_CONTEXT, MemberContext.builder().build());\r\n    return context.put(ContextType.LOG_CONTEXT, LogContext.builder().traceId(TraceUtil.createTraceValue()).build());\r\n})\r\n\r\n// context read\r\n    return Mono.deferContextual(contextView -> {\r\n        MemberContext memberContext = (MemberContext) ContextUtils.getContext(contextView, ContextType.MEMBER_CONTEXT);    \r\n});</code></pre></div>\n<p>세 번째는 블로킹 라이브러리를 사용할 수 없습니다. 언급한 바와 같이 WebFlux는 스프링 MVC와 달리 연결을 요청할 때마다 스레드를 할당하지 않고, 적은 수의 Worker 스레드를 공용으로 사용하는 리액티브 프로그래밍 모델입니다.</p>\n<p>이처럼 적은 수의 Worker 스레드를 사용하기 때문에 스프링 MVC에서 사용하던 블로킹 라이브러리를 그대로 사용하면, 전체 시스템이 블로킹될 수 있습니다. 참고로 RestTemplate은 대표적인 블로킹 I/O를 사용하는 라이브러리입니다.</p>\n<p>만약 RestTemplate을 이용하여 API 호출 중 대기시간이 길어질 경우, 스프링 MVC는 해당 API만 영향을 주지만 WebFlux는 전체 시스템에 영향을 주게 됩니다.</p>\n<p>WebFlux에서 대표적으로 사용할 수 있는 논-블로킹 라이브러리는 다음 그림과 같으며, 이 중에서 R2DBC(Reactive Relational Database Connectivity)는 아직까지 지원 데이터베이스 부족, 커뮤니티와 지원 부족, 개발의 복잡성 등의 문제가 있기 때문에 신중히 사용해야 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/98e0538075e2c6d9c021f274bae652ce/6937a/syrup-09.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.45569620253164%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACcElEQVR42k1Ta1MaQRDk//+JxKTMhzwliUmVhURBFBAURb2HcC84uBfcwcnht07P4lle1dTuzt72ds/0VvI8R5Zl8DwPruuq0fd9rFYrbIoC8o0WKY4sF3Xbw/f+AN9616gOhvjc7an1kTlGzZ6gNwtQ2Ww2WK/XmE6nCIIAs9lMAUpu+/ysAGfrHL15gGtGwzDR0A20bQdN8xGnmo7eZIp+EMJMlqgUZCGg2+0WURQhjmM1l9zzG8A+bx8EEYY8NAhjBdb1JhiS/Q3X/TkBFwR8enpCKVvXdRiGoeaSKwgsn7XMcOxMcOr5aExmqFP+l3YXh3cPai35ujvFFS9UDOWwAAszYSXsZC17BcdkU0CLE0paQI8SPIQRHnmJSNSZN5iXfS9boSK1kgZICEPTNFHmZMw5ysHDsYMaWfzWH/H+pIH98w7HJr5e3aBG9n+43/HnqAirVzZvQliK5DxfI2YNrWUKJ13BIQsZ7TR7DcmNWb85/1MMBVA6q2maCum05HYMMxgs/K+RjU+s216zhXdk9rHVxoezC+y3L7HXaOGAzDvzaMewrFkpVeYlwy3ZSg3vo1jV7o7dlHpp0S501u+elrnjnis1lIZIhGGojC0h1hHw0thjyq05Hk6khsMHHNDMP2ns6uAWPzg/thzUPXaZl1VKdmmaKnNLLBYLdcn2xTbiw0tfjB3iYmzTzAbORxZajCaN3pv4NP6LsQVQDoupkyRRsVwud4AvxvZYhjY7KIdatoszMjo1RyoaBO1yr0Pja5SvJIs8ecOO48CyrNenV5RvmZLr7gRNMvl7r1HurZJdvRqo+T9eckLJ10GE/8Fnt/KBdF2EAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-09\"\n        title=\"\"\n        src=\"/static/98e0538075e2c6d9c021f274bae652ce/f058b/syrup-09.png\"\n        srcset=\"/static/98e0538075e2c6d9c021f274bae652ce/c26ae/syrup-09.png 158w,\n/static/98e0538075e2c6d9c021f274bae652ce/6bdcf/syrup-09.png 315w,\n/static/98e0538075e2c6d9c021f274bae652ce/f058b/syrup-09.png 630w,\n/static/98e0538075e2c6d9c021f274bae652ce/40601/syrup-09.png 945w,\n/static/98e0538075e2c6d9c021f274bae652ce/6937a/syrup-09.png 1094w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Syrup 웹 게이트웨이는 리액티브 환경에서 외부 API 연동을 위해 WebClient를 사용하며, MemCached 사용을 위해 com.spotify.folsom(<a href=\"https://github.com/spotify/folsom\">https://github.com/spotify/folsom</a> )을 사용합니다.</p>\n<p>네 번째는 스프링 MVC에 비해 생태계가 작기 때문에 사용할 수 있는 라이브러리의 선택지가 좁습니다.</p>\n<p>Syrup은 다음 그림과 같이 A 서버에서 MemCached에 값을 저장하고, B 서버에서 MemCached의 값을 읽어서 사용하는 경우가 있습니다. A 서버와 B 서버가 동일한 라이브러리 패키지와  Key 해싱 알고리즘을 사용한다면, 다중 노드를 사용하더라도 문제 없이 동작됩니다(캐시 HIT).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 526px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c171ced0f1e6cb0d17e222a64509866e/2d7ab/syrup-10.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.60759493670886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABsUlEQVR42n2QS28SYRSG50eauHHhSn+BC1fGH9HEhbTcSWcwdlG1rZWmrVzGCgyXUkYKQssUmNamEKllLjweMDTERb/kfCd5z5P3XBSWnut5FKweR90eeasvMWDbKLNbrvJZcqp6Qv5iMK/p5z2qfZvpdLpsgTL7FtLtxGG72SZ2XCdYrhGpnLCm51lJ51j5miN0VCQsprNavGZycNbFcd0HDB2HT40WL3YPeBxO8Oz9R14f6jzVNngST/JqP8vzjQ88CkR4KUz63GLykKEjK+cEihoV3qR1gt+LrJeqvJXJVvMGaqVGWGqrhTLqsYnR6+P5PguP2fbKsvvVpY1t95n63gLB91w8mdxxJrjOnWg+o9ENnbM2netb7tz/briz8xNVle5qgVAoTTB4SPKdQTSqs7fXxnW9e7hUGpBIFInFdAKBfdbCWdbVIvH4NzY3a9LUR0mlLJLJooA5NC0vWScSSQuU40uqi3Xxe242HP4hk7GFNeaMphWEyYp5Vppn2Npq0emMUJrNEaenvzDNy/uo1wc0GleiD7mWtWZvPJ7Qag1FX2J//GNN0xb2Rs415i8sXzeU/tU2HAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-10\"\n        title=\"\"\n        src=\"/static/c171ced0f1e6cb0d17e222a64509866e/2d7ab/syrup-10.png\"\n        srcset=\"/static/c171ced0f1e6cb0d17e222a64509866e/c26ae/syrup-10.png 158w,\n/static/c171ced0f1e6cb0d17e222a64509866e/6bdcf/syrup-10.png 315w,\n/static/c171ced0f1e6cb0d17e222a64509866e/2d7ab/syrup-10.png 526w\"\n        sizes=\"(max-width: 526px) 100vw, 526px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>하지만 WebFlux는 블로킹 I/O를 사용하는 com.whalin.MemCached를 적용할 수 없었고, 논-블로킹 I/O를 사용하는 com.spotify.folsom을 사용해야 합니다.</p>\n<p>두 라이브러리가 지원하는 Key 해싱 알고리즘이 다르기 때문에 다음 그림과 같이 다중 노드 환경에서 캐시 Miss가 발생됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f6d07432201f97448a8e1fe27c5d54d6/29492/syrup-11.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0ElEQVR42mWRQXPSUBSF+ZmOG8e9bhx/ga5dqIuOugAUqG1dtEgZGkphFAoh0EJQIAihpm0MUEahERBCPh+xHTt6Z87cd+9779zzzvMhwuVP2LMZeeMM+cykZFp8bHfYKcjsVarEZIVMq40i+kWxX1idEfi1WHAzfB7hFePg0ibeOeHtZ41wXUCt81o55pV8xEu5xIao18VeSGCz8YVk12A8nXJT1H+E260OD/bS3A5tcP99gse5Ine3otxZf8ejD3nuxSRuBSI8jCdJnZwynvxDuFy6OM7S64wmM/b1r6wVyjw5yPKieMybyiee5xWeZfMEy1XWikc8zcn4j1VypyY/53OPaHmlynf9dlc0Li56/Bh/F+uFN9N1lyyER47j4Ig8F5dXcIWI3mCAdX4OwlPGl389lCSd3d060ahKOJxla7NIItFge0dFUUxv0HX0ej20ZpNSqUQmnWZfkpBTKcqHebRWC9u28cViOqGQTDB4SCSiEAhk8fuzXi0lDfp92yObCK/a7TZqrUY6k0ESZPF4nITIB6Ju1OuYpolP00ao6jeqVdNDpWJSLhvUahbN5kjYMPEIp+I3Vwoty8IwDHRdR9M0b0i32xWD+wyHQ34DfMA44xinf0AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-11\"\n        title=\"\"\n        src=\"/static/f6d07432201f97448a8e1fe27c5d54d6/29492/syrup-11.png\"\n        srcset=\"/static/f6d07432201f97448a8e1fe27c5d54d6/c26ae/syrup-11.png 158w,\n/static/f6d07432201f97448a8e1fe27c5d54d6/6bdcf/syrup-11.png 315w,\n/static/f6d07432201f97448a8e1fe27c5d54d6/29492/syrup-11.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>결국 특정 라이브러리를 사용할 수 없어서 기존 로직을 변경하거나 다른 우회적인 방법을 찾아야 하는 시행착오를 겪었습니다.</p>\n<h3>개선 결과</h3>\n<p>WebFlux, Server Sent Events, Next.js를 통한 웹 게이트웨이와 웹 서버를 개선한 이후, Syrup의 전체적인 화면 로딩 속도가 개선되었습니다.</p>\n<p>(1) API 요청 건수는 기존 대비 70% 이상 줄었습니다. 개별로 호출되던 API가 하나의 API로 통합된 결과입니다.</p>\n<p>(2) API 응답 속도는 기존 대비 50% 이상 개선되었습니다. 순차적으로 호출되던 외부 API가 비동기로 호출된 결과입니다.</p>\n<p>(3) API 이외에 Next.js 적용을 통한 렌더링 속도 개선 효과도 확인할 수 있었습니다.<br>\n또한 LightHouse를 통한 웹 페이지 성능을 확인해 보았는데요. 특히 이번 개선으로 First Contentful Paint, Total Blocking Time, Speed Index 값이 개선된 것을 확인할 수 있었습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3272365d2a7412071f93309caa3150c4/d74fe/syrup-12.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB2ElEQVR42o1SyZLTMBT0//8SxYlDYAI1wZkkXuJ9w449kWxJXpPmyYFQc0NVXV1vUav1JKOua+R5jqIoUJYl0ixbkeUFzp6POIoQxTFOloUkjnDa7bD78QWB/YpPm8/4/rqFbds4Ho9wXReG53k4HA74aZpwHRu+58I7u4i8E6y3LTw/gEPNe6oH1BvSJvccIEgSmHvKUT0muI6DNE1hWHSyFvz28oKDucPACvR1irq0YIdbCDmjCbZoygyXpoL5tkGZVwjLAF+tDTgTuCZ7VIkD3goYEV1Ju9RI6NS+HzCOI4RSeG/5GkvRQEmBjlDzhmIJJgTVGVrZ06EMvOPoKG9kNC8tpAW15fv9Dr00f8AjiXEYCT2m3MOtfcdU+FjaBmOVQbEGhn6Q/xO840YsyflEN5h5jUUJ4gazbNEGFtqqgOHQMPUMwzAk4ZSuJsnBgKFXhH7FI35wr9Ra61enI4ZRY0DXjzQSBUO703P0fX91KBRtnGfCQo0TzUg3z+gUsZrR/mX5kYdRQQj+b4baqRZWVYqpYxivFRbJoS4FFKfHqf+wjhmj+NczLxnHVMcQdQ5Df2gtmNNHruhjT/kZC7tgLkPMrFp54Q++rRw8+ZlnJWZ6nOF6wW8sle4FjD9i1QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"syrup-12\"\n        title=\"\"\n        src=\"/static/3272365d2a7412071f93309caa3150c4/f058b/syrup-12.png\"\n        srcset=\"/static/3272365d2a7412071f93309caa3150c4/c26ae/syrup-12.png 158w,\n/static/3272365d2a7412071f93309caa3150c4/6bdcf/syrup-12.png 315w,\n/static/3272365d2a7412071f93309caa3150c4/f058b/syrup-12.png 630w,\n/static/3272365d2a7412071f93309caa3150c4/40601/syrup-12.png 945w,\n/static/3272365d2a7412071f93309caa3150c4/d74fe/syrup-12.png 1164w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>(4) 마지막으로 실제 앱 실행을 통한 비교 시험에서도 성능이 좋아진 것을 확인할 수 있었습니다.<br>\n개선 전(3.52s) 대비, 개선 후(1.96s) 최초 로딩 속도가 1.56s 개선되었습니다.</p>\n<h3>마무리</h3>\n<p>지금까지 Syrup 모바일 웹의 몇 가지 개선 사례를 공유 드렸습니다. 개선 과정에서 WebFlux, Server Sent Events, Next.js를 활용한 성능 개선에 집중했고, 실제로 체감할 수 있는 성능 향상을 달성했습니다.</p>\n<p>이러한 결과를 얻기까지 WebFlux, Server Sent Events, Next.js를 도입에 따른 레퍼런스 부족, 코딩스킬 경험의 부족으로 인한 여러 시행착오의 과정을 겪었지만 그 결과 실질적인 성능 향상 뿐만 아니라 개발 관점에서 많은 성장과 다양한 경험을 할 수 있었습니다.</p>\n<p>짧은 글이나마 과정을 정리한 이 글이 독자 여러분의 성장에 작은 밑거름이 될 수 있길 바랍니다.</p>\n<p>감사합니다.</p>\n<p>모으는 재미, 불리는 맛 Syrup</p>\n<p>Google play<br>\n<a href=\"https://play.google.com/store/apps/details?id=com.skt.skaf.OA00026910&#x26;hl=ko&#x26;gl=US\">https://play.google.com/store/apps/details?id=com.skt.skaf.OA00026910&#x26;hl=ko&#x26;gl=US</a><br>\nApple App Store<br>\n<a href=\"https://apps.apple.com/kr/app/syrup-%EC%8B%9C%EB%9F%BD/id430282710\">https://apps.apple.com/kr/app/syrup-%EC%8B%9C%EB%9F%BD/id430282710</a></p>","frontmatter":{"title":"Syrup 모바일 웹 개선 사례","date":"December 12, 2023","description":"모으는 재미, 불리는 맛 Syrup, SK플래닛의 대표 서비스 Syrup의 웹 개선 사례를 소개합니다.","author":"changho"}},"previous":{"fields":{"slug":"/wezuro/"},"frontmatter":{"title":"SK플래닛 신규 서비스 Wezuro 브랜드 구축 스토리"}},"next":{"fields":{"slug":"/rbarhis-ai/"},"frontmatter":{"title":"ARHIS: 음향 기반 도로 노면 검지 솔루션"}}},"pageContext":{"id":"709f10b8-c22f-50c2-98d0-b101f3ab257a","previousPostId":"1366a0db-081e-51d4-b3d4-da899a61bf7a","nextPostId":"b503c27c-1abf-5a89-822c-5e092293fbc9"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}